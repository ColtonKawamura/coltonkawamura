<?xml version="1.0" encoding="utf-8"?><feed xmlns="http://www.w3.org/2005/Atom" xml:lang="en"><generator uri="https://jekyllrb.com/" version="4.3.3">Jekyll</generator><link href="https://coltonkawamura.github.io/coltonkawamura/feed.xml" rel="self" type="application/atom+xml"/><link href="https://coltonkawamura.github.io/coltonkawamura/" rel="alternate" type="text/html" hreflang="en"/><updated>2025-08-15T17:32:05+00:00</updated><id>https://coltonkawamura.github.io/coltonkawamura/feed.xml</id><title type="html">blank</title><subtitle>A simple, whitespace theme for academics. Based on [*folio](https://github.com/bogoli/-folio) design. </subtitle><entry><title type="html">A Visual Guide to the Uncertainty Principle</title><link href="https://coltonkawamura.github.io/coltonkawamura/blog/2025/visual-guide/" rel="alternate" type="text/html" title="A Visual Guide to the Uncertainty Principle"/><published>2025-08-02T16:40:16+00:00</published><updated>2025-08-02T16:40:16+00:00</updated><id>https://coltonkawamura.github.io/coltonkawamura/blog/2025/visual-guide</id><content type="html" xml:base="https://coltonkawamura.github.io/coltonkawamura/blog/2025/visual-guide/"><![CDATA[<p>The Heisenberg uncertainly principle captures the experimental and theoretical phenomena that you can’t ever really have full information about both a particle’s position and momentum at the same time. To increase certainty in one, you must give up certainty in the other. Quantitatively, it is described as follows,</p> \[\sigma_x \sigma_p \geq \frac{\hbar}{2}\] <p>A dive into Fourier analysis can explain this much more analytically, but for now, let’s stick to these animations.</p> <h1 id="where-is-the-wave-and-whats-its-momentum">Where is the Wave and What’s its Momentum?</h1> <p>In the image below: ask yourself Where is the wave?</p> <p><img src="/assets/img/visualGuide1.gif" alt="Initial Diagram"/></p> <p>You can probably tell with some certainty that the wave is where that hump moving to the right is. Now ask yourself this question What is the wavelength? This question is a little hard to answer since the wavelength is the distance between repeating parts of a wave. But what if we had a longer pulse of a wave?</p> <p><img src="/assets/img/visualGuide2.gif" alt="Second Diagram"/></p> <p>Here, the wavelength is much easier to determine since the wave repeats itself. But what happened to the position of the wave? It’s smeared across the length of the pulse — it’s more uncertain. We just traded certainty of the wavelength for the uncertainty of its position.</p> <h1 id="momentum-links-to-other-information">Momentum Links to Other Information</h1> <p>So what does this have to do with momentum? On quantum scales, particle’s wave-like behavior dominates. Physicist de Broglie linked particle and wave characteristics together with the constant, called Plank’s constant:</p> \[h = p \lambda\] <h1 id="the-big-picture">The Big Picture</h1> <p>What does this mean for our everyday lives? One of the many examples includes solid-state hard drives, which takes advantage of the phenomena the uncertainty principle models. A fluctuating position of a particle can enable it to move through a barrier that it classically couldn’t. This allows electrons to be stored in space without the use of a capacitor, which allows for the non-volatile flash memory we have in most modern electronics.</p>]]></content><author><name></name></author><category term="physics"/><category term="teaching"/><summary type="html"><![CDATA[Sometimes pictures help.]]></summary></entry><entry><title type="html">How to Probably Win at Rock, Paper, Scissors</title><link href="https://coltonkawamura.github.io/coltonkawamura/blog/2025/rock-paper-scissors/" rel="alternate" type="text/html" title="How to Probably Win at Rock, Paper, Scissors"/><published>2025-08-01T16:40:16+00:00</published><updated>2025-08-01T16:40:16+00:00</updated><id>https://coltonkawamura.github.io/coltonkawamura/blog/2025/rock-paper-scissors</id><content type="html" xml:base="https://coltonkawamura.github.io/coltonkawamura/blog/2025/rock-paper-scissors/"><![CDATA[<p>The internet is riddled with articles about the best strategies for rock, paper, scissors (RPS), and they all generally suggest the same thing. But are these strategies actually effective?</p> <h1 id="the-strategy">The Strategy</h1> <p>I should start by summarizing the applicable parts of the <a href="https://arxiv.org/pdf/1404.5199v1">2014 Chinese study</a> where everyone else got their information. The researchers found that players will throw, on average, a distribution of 36% rocks, 33% papers, and 31% scissors (ignoring the standard deviation). This is slightly different than the Nash equilibrium for RPS, which predicts that the optimal strategy is 1/3 rock, 1/3 paper, and 1/3 scissors. Furthermore, the Chinese study found that if a player lost, they will most likely shift clockwise according to this figure:</p> <p><img src="/assets/img/rpsNash.gif" alt="Initial Diagram" title="With Nash"/></p> <p>If a player wins or ties, they are significantly more likely to repeat their last action. If you’re armed with these data, you could formulate the following strategy:</p> <ul> <li>Play paper first (since most people throw rock first)</li> <li>If you win: Play what your opponent just lost with.</li> <li>If you lost or tie: Play what was not played last round</li> </ul> <p>This is similar to the other information on the internet. But how effective is this in practice? That’s where computers come in. I armed one bot (let’s call it Roboshambo) with the strategy described above and the other bot (Humans) with the average distribution of participants found in the paper. I then let them duke it out for 1000 iterations through a Monte Carlo simulation of best two-of-three games. Here’s the result:</p> <figure> <picture> <source class="responsive-img-srcset" srcset="/coltonkawamura/assets/img/rpsRoboWins-480.webp 480w,/coltonkawamura/assets/img/rpsRoboWins-800.webp 800w,/coltonkawamura/assets/img/rpsRoboWins-1400.webp 1400w," sizes="95vw" type="image/webp"/> <img src="/coltonkawamura/assets/img/rpsRoboWins.gif" class="img-fluid rounded z-depth-1" width="100%" height="auto" data-zoomable="" loading="lazy" onerror="this.onerror=null; $('.responsive-img-srcset').remove();"/> </picture> </figure> <p>Roboshambo was able to walk away with a 71% win percentage over the Humans. That’s a big swing in your favor if you use the strategy suggested above. Randomness: The Best Counter-Strategy</p> <p>Let’s take things a little deeper: if you’re playing against someone who you think has some sort of strategy, like the one demonstrated above, but you can’t quite figure out what approach they’ll employ, what’s the best counter-strategy for you? Play 1/3 rock, 1/3 paper, 1/3 scissors, the original Nash equilibrium of RPS. If one player acts completely random, unlike what happens with humans in real life, then the best record their opponent can have, no matter their strategy, is 50%.</p> <p>To demonstrate this, let’s place our bots against each other again; Roboshambo plays with the same strategy as before, while the Humans play according to the Nash equilibrium. For 1000 iterations, the results are:</p> <figure> <picture> <source class="responsive-img-srcset" srcset="/coltonkawamura/assets/img/rpsNash-480.webp 480w,/coltonkawamura/assets/img/rpsNash-800.webp 800w,/coltonkawamura/assets/img/rpsNash-1400.webp 1400w," sizes="95vw" type="image/webp"/> <img src="/coltonkawamura/assets/img/rpsNash.gif" class="img-fluid rounded z-depth-1" width="100%" height="auto" data-zoomable="" loading="lazy" onerror="this.onerror=null; $('.responsive-img-srcset').remove();"/> </picture> </figure> <p>The Monte Carlo simulation places the win ratio to about 50% — precisely what the theory predicts! This magnifies the power of equilibrium in zero-sum games like RPS. So next time you play against a friend who might have a strategy in RPS, it might be best to try to be like our Human bot and play as random as possible. If you don’t think they have a strategy, then go ahead and try out the tactic at the beginning of this article. You might just score a 71% win percentage!</p>]]></content><author><name></name></author><category term="computational"/><category term="computational"/><summary type="html"><![CDATA[Using robots to play RPS]]></summary></entry><entry><title type="html">How to Combine Two Plots in Matlab</title><link href="https://coltonkawamura.github.io/coltonkawamura/blog/2024/combine-two-figures-matlab/" rel="alternate" type="text/html" title="How to Combine Two Plots in Matlab"/><published>2024-05-01T00:32:13+00:00</published><updated>2024-05-01T00:32:13+00:00</updated><id>https://coltonkawamura.github.io/coltonkawamura/blog/2024/combine-two-figures-matlab</id><content type="html" xml:base="https://coltonkawamura.github.io/coltonkawamura/blog/2024/combine-two-figures-matlab/"><![CDATA[<p>Just replace your two figures for <code class="language-plaintext highlighter-rouge">f1</code> and <code class="language-plaintext highlighter-rouge">f2</code>.</p> <div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>% Define the two figure files that are on the MATLAB path
% These are the only <span class="s2">"inputs"</span> to this script
f1 <span class="o">=</span> <span class="s1">'fig1.fig'</span><span class="p">;</span>
f2 <span class="o">=</span> <span class="s1">'fig2.fig'</span><span class="p">;</span>

% Open the figures
fig1 <span class="o">=</span> openfig<span class="o">(</span>f1<span class="o">)</span><span class="p">;</span>
fig2 <span class="o">=</span> openfig<span class="o">(</span>f2<span class="o">)</span><span class="p">;</span>

% get axes handles - this assumes there is only 1 axes per figure!
fig1ax <span class="o">=</span> gca<span class="o">(</span>fig1<span class="o">)</span><span class="p">;</span>
fig2ax <span class="o">=</span> gca<span class="o">(</span>fig2<span class="o">)</span><span class="p">;</span>
leg1 <span class="o">=</span> findobj<span class="o">(</span>fig1,<span class="s1">'Type'</span>,<span class="s1">'legend'</span><span class="o">)</span><span class="p">;</span>
leg2 <span class="o">=</span> findobj<span class="o">(</span>fig2,<span class="s1">'Type'</span>,<span class="s1">'legend'</span><span class="o">)</span><span class="p">;</span>

% Get axis children
fig1axChildren <span class="o">=</span> get<span class="o">(</span>fig1ax,<span class="s1">'Children'</span><span class="o">)</span><span class="p">;</span>
fig2axChildren <span class="o">=</span> get<span class="o">(</span>fig2ax,<span class="s1">'Children'</span><span class="o">)</span><span class="p">;</span>

% Create new fig, copy items from fig 1
% This will maintain <span class="nb">set </span>properties such as color
figFinal <span class="o">=</span> figure<span class="o">()</span><span class="p">;</span>
ax <span class="o">=</span> axes<span class="o">(</span>figFinal<span class="o">)</span><span class="p">;</span>
h1 <span class="o">=</span> copyobj<span class="o">(</span>fig1axChildren, ax<span class="o">)</span><span class="p">;</span>


% Copy items from fig 2
h2 <span class="o">=</span> copyobj<span class="o">(</span>fig2axChildren, ax<span class="o">)</span><span class="p">;</span>
<span class="nb">set</span><span class="o">(</span>gca, <span class="s1">'YScale'</span>, <span class="s1">'log'</span><span class="o">)</span>
<span class="nb">set</span><span class="o">(</span>gca, <span class="s1">'XScale'</span>, <span class="s1">'log'</span><span class="o">)</span>
grid on


% Add legend to same location as the legend <span class="k">in </span>fig2 
% but only include objects with a defined DisplayName
h <span class="o">=</span> <span class="o">[</span>h2<span class="p">;</span>h1]<span class="p">;</span>
hasDisplayName <span class="o">=</span> ~cellfun<span class="o">(</span><span class="s1">'isempty'</span>,get<span class="o">(</span>h,<span class="s1">'DisplayName'</span><span class="o">))</span><span class="p">;</span>
legend<span class="o">(</span>ax, h<span class="o">(</span>hasDisplayName<span class="o">)</span>,<span class="s1">'Location'</span>, leg1.Location, <span class="s1">'Interpreter'</span>, <span class="s1">'Latex'</span><span class="o">)</span>


% Copy axis labels
xlabel<span class="o">(</span>ax, fig2ax.XLabel.String, <span class="s1">'Interpreter'</span>, <span class="s1">'Latex'</span>, <span class="s1">'FontSize'</span>, 20<span class="o">)</span>
ylabel<span class="o">(</span>ax, fig2ax.YLabel.String, <span class="s1">'Interpreter'</span>, <span class="s1">'Latex'</span>, <span class="s1">'FontSize'</span>, 20<span class="o">)</span>
<span class="nb">set</span><span class="o">(</span>get<span class="o">(</span>gca, <span class="s1">'ylabel'</span><span class="o">)</span>, <span class="s1">'rotation'</span>, 0<span class="o">)</span><span class="p">;</span>
</code></pre></div></div>]]></content><author><name></name></author><category term="computing"/><category term="matlab"/><summary type="html"><![CDATA[How to Combine Two Figures in Matlab Including all the Data.]]></summary></entry><entry><title type="html">Drag Coefficent in 2D in Matlab</title><link href="https://coltonkawamura.github.io/coltonkawamura/blog/2024/cfd/" rel="alternate" type="text/html" title="Drag Coefficent in 2D in Matlab"/><published>2024-04-29T23:36:10+00:00</published><updated>2024-04-29T23:36:10+00:00</updated><id>https://coltonkawamura.github.io/coltonkawamura/blog/2024/cfd</id><content type="html" xml:base="https://coltonkawamura.github.io/coltonkawamura/blog/2024/cfd/"><![CDATA[<h1 id="simulating-flow-over-a-cylinder-using-matlab-and-the-lattice-boltzmann-method">Simulating Flow Over a Cylinder Using MATLAB and the Lattice Boltzmann Method</h1> <h2 id="introduction">Introduction</h2> <p>Computational Fluid Dynamics (CFD) is a powerful tool used to analyze fluid flow problems. In this tutorial, we’ll simulate <strong>2D flow past a cylinder</strong> using <strong>MATLAB</strong> and the <strong>Lattice Boltzmann Method (LBM)</strong> to compute the drag coefficient. We’ll also visualize velocity fields and streamline patterns.</p> <hr/> <h2 id="problem-setup">Problem Setup</h2> <p>We’ll analyze the flow past a cylinder with the following parameters:</p> <div class="language-matlab highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">% Problem Parameters</span>
<span class="n">D</span> <span class="o">=</span> <span class="mf">1.0</span><span class="p">;</span>            <span class="c1">% Cylinder diameter (m)</span>
<span class="n">U</span> <span class="o">=</span> <span class="mf">1.0</span><span class="p">;</span>            <span class="c1">% Free-stream velocity (m/s)</span>
<span class="n">rho</span> <span class="o">=</span> <span class="mf">1.0</span><span class="p">;</span>          <span class="c1">% Fluid density (kg/m^3)</span>
<span class="n">mu</span> <span class="o">=</span> <span class="mf">0.01</span><span class="p">;</span>          <span class="c1">% Dynamic viscosity (Pa.s)</span>
<span class="n">Re</span> <span class="o">=</span> <span class="n">rho</span> <span class="o">*</span> <span class="n">U</span> <span class="o">*</span> <span class="n">D</span> <span class="p">/</span> <span class="n">mu</span><span class="p">;</span> <span class="c1">% Reynolds number</span>

<span class="c1">% Domain size</span>
<span class="n">Lx</span> <span class="o">=</span> <span class="mi">20</span><span class="p">;</span>  <span class="c1">% Length of domain in x-direction</span>
<span class="n">Ly</span> <span class="o">=</span> <span class="mi">10</span><span class="p">;</span>  <span class="c1">% Height of domain in y-direction</span>

<span class="nb">fprintf</span><span class="p">(</span><span class="s1">'Reynolds number: %.2f\n'</span><span class="p">,</span> <span class="n">Re</span><span class="p">);</span>
</code></pre></div></div> <p>The Reynolds number provides insight into flow characteristics, helping to determine if the flow is laminar or turbulent.</p> <hr/> <h2 id="mesh-generation">Mesh Generation</h2> <p>We’ll create a rectangular computational domain and place the cylinder at the center:</p> <div class="language-matlab highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">% Grid resolution</span>
<span class="n">Nx</span> <span class="o">=</span> <span class="mi">200</span><span class="p">;</span> <span class="c1">% Grid points in x-direction</span>
<span class="n">Ny</span> <span class="o">=</span> <span class="mi">100</span><span class="p">;</span> <span class="c1">% Grid points in y-direction</span>

<span class="n">x</span> <span class="o">=</span> <span class="nb">linspace</span><span class="p">(</span><span class="o">-</span><span class="n">Lx</span><span class="p">/</span><span class="mi">2</span><span class="p">,</span> <span class="n">Lx</span><span class="p">/</span><span class="mi">2</span><span class="p">,</span> <span class="n">Nx</span><span class="p">);</span>
<span class="n">y</span> <span class="o">=</span> <span class="nb">linspace</span><span class="p">(</span><span class="o">-</span><span class="n">Ly</span><span class="p">/</span><span class="mi">2</span><span class="p">,</span> <span class="n">Ly</span><span class="p">/</span><span class="mi">2</span><span class="p">,</span> <span class="n">Ny</span><span class="p">);</span>
<span class="p">[</span><span class="n">X</span><span class="p">,</span> <span class="n">Y</span><span class="p">]</span> <span class="o">=</span> <span class="nb">meshgrid</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">);</span>

<span class="c1">% Define cylinder boundary condition</span>
<span class="p">[</span><span class="n">theta</span><span class="p">,</span> <span class="n">r</span><span class="p">]</span> <span class="o">=</span> <span class="nb">cart2pol</span><span class="p">(</span><span class="n">X</span><span class="p">,</span> <span class="n">Y</span><span class="p">);</span>
<span class="n">cylinder_mask</span> <span class="o">=</span> <span class="n">r</span> <span class="o">&lt;</span> <span class="n">D</span><span class="p">/</span><span class="mi">2</span><span class="p">;</span>   <span class="c1">% Creates the surface mask</span>

<span class="c1">% Visualize the mesh</span>
<span class="nb">figure</span><span class="p">;</span>
<span class="nb">contourf</span><span class="p">(</span><span class="n">X</span><span class="p">,</span> <span class="n">Y</span><span class="p">,</span> <span class="nb">double</span><span class="p">(</span><span class="n">cylinder_mask</span><span class="p">),</span> <span class="p">[</span><span class="mf">0.5</span><span class="p">,</span> <span class="mf">0.5</span><span class="p">],</span> <span class="s1">'k'</span><span class="p">);</span>
<span class="nb">axis</span> <span class="n">equal</span><span class="p">;</span>
<span class="nb">title</span><span class="p">(</span><span class="s1">'Mesh and Cylinder Location'</span><span class="p">);</span>
<span class="nb">xlabel</span><span class="p">(</span><span class="s1">'X'</span><span class="p">);</span>
<span class="nb">ylabel</span><span class="p">(</span><span class="s1">'Y'</span><span class="p">);</span>
<span class="nb">grid</span> <span class="n">on</span><span class="p">;</span>
</code></pre></div></div> <hr/> <h2 id="solving-the-navier-stokes-equations-using-lattice-boltzmann-method">Solving the Navier-Stokes Equations Using Lattice Boltzmann Method</h2> <p>We’ll now solve the Navier-Stokes equations using the LBM approach with finite difference approximations.</p> <div class="language-matlab highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">% Initialize velocity and pressure fields</span>
<span class="n">u</span> <span class="o">=</span> <span class="nb">zeros</span><span class="p">(</span><span class="n">Ny</span><span class="p">,</span> <span class="n">Nx</span><span class="p">);</span>
<span class="n">v</span> <span class="o">=</span> <span class="nb">zeros</span><span class="p">(</span><span class="n">Ny</span><span class="p">,</span> <span class="n">Nx</span><span class="p">);</span>
<span class="n">p</span> <span class="o">=</span> <span class="nb">zeros</span><span class="p">(</span><span class="n">Ny</span><span class="p">,</span> <span class="n">Nx</span><span class="p">);</span>

<span class="n">dx</span> <span class="o">=</span> <span class="n">Lx</span> <span class="p">/</span> <span class="p">(</span><span class="n">Nx</span> <span class="o">-</span> <span class="mi">1</span><span class="p">);</span>
<span class="n">dy</span> <span class="o">=</span> <span class="n">Ly</span> <span class="p">/</span> <span class="p">(</span><span class="n">Ny</span> <span class="o">-</span> <span class="mi">1</span><span class="p">);</span>
<span class="n">dt</span> <span class="o">=</span> <span class="mf">0.01</span><span class="p">;</span>  <span class="c1">% Time step</span>

<span class="n">maxIter</span> <span class="o">=</span> <span class="mi">1000</span><span class="p">;</span>
<span class="k">for</span> <span class="n">iter</span> <span class="o">=</span> <span class="mi">1</span><span class="p">:</span><span class="n">maxIter</span>
    <span class="c1">% Compute velocity with central difference scheme</span>
    <span class="n">u_new</span> <span class="o">=</span> <span class="n">u</span> <span class="o">-</span> <span class="n">dt</span> <span class="o">*</span> <span class="p">((</span><span class="n">u</span><span class="p">(:,</span> <span class="p">[</span><span class="mi">2</span><span class="p">:</span><span class="k">end</span><span class="p">,</span> <span class="k">end</span><span class="p">])</span> <span class="o">-</span> <span class="n">u</span><span class="p">(:,</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">:</span><span class="k">end</span><span class="o">-</span><span class="mi">1</span><span class="p">]))</span> <span class="p">/</span> <span class="p">(</span><span class="mi">2</span> <span class="o">*</span> <span class="n">dx</span><span class="p">)</span> <span class="k">...</span>
                      <span class="o">+</span> <span class="p">(</span><span class="n">v</span><span class="p">([</span><span class="mi">2</span><span class="p">:</span><span class="k">end</span><span class="p">,</span> <span class="k">end</span><span class="p">],</span> <span class="p">:)</span> <span class="o">-</span> <span class="n">v</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">:</span><span class="k">end</span><span class="o">-</span><span class="mi">1</span><span class="p">],</span> <span class="p">:))</span> <span class="p">/</span> <span class="p">(</span><span class="mi">2</span> <span class="o">*</span> <span class="n">dy</span><span class="p">))</span> <span class="k">...</span>
            <span class="o">+</span> <span class="n">dt</span> <span class="o">*</span> <span class="n">mu</span> <span class="o">*</span> <span class="p">((</span><span class="n">u</span><span class="p">(:,</span> <span class="p">[</span><span class="mi">2</span><span class="p">:</span><span class="k">end</span><span class="p">,</span> <span class="k">end</span><span class="p">])</span> <span class="o">-</span> <span class="mi">2</span><span class="o">*</span><span class="n">u</span> <span class="o">+</span> <span class="n">u</span><span class="p">(:,</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">:</span><span class="k">end</span><span class="o">-</span><span class="mi">1</span><span class="p">]))</span> <span class="p">/</span> <span class="n">dx</span><span class="o">^</span><span class="mi">2</span> <span class="k">...</span>
                      <span class="o">+</span> <span class="p">(</span><span class="n">u</span><span class="p">([</span><span class="mi">2</span><span class="p">:</span><span class="k">end</span><span class="p">,</span> <span class="k">end</span><span class="p">],</span> <span class="p">:)</span> <span class="o">-</span> <span class="mi">2</span><span class="o">*</span><span class="n">u</span> <span class="o">+</span> <span class="n">u</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">:</span><span class="k">end</span><span class="o">-</span><span class="mi">1</span><span class="p">],</span> <span class="p">:))</span> <span class="p">/</span> <span class="n">dy</span><span class="o">^</span><span class="mi">2</span><span class="p">);</span>

    <span class="n">v_new</span> <span class="o">=</span> <span class="n">v</span> <span class="o">-</span> <span class="n">dt</span> <span class="o">*</span> <span class="p">((</span><span class="n">u</span><span class="p">(:,</span> <span class="p">[</span><span class="mi">2</span><span class="p">:</span><span class="k">end</span><span class="p">,</span> <span class="k">end</span><span class="p">])</span> <span class="o">-</span> <span class="n">u</span><span class="p">(:,</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">:</span><span class="k">end</span><span class="o">-</span><span class="mi">1</span><span class="p">]))</span> <span class="p">/</span> <span class="p">(</span><span class="mi">2</span> <span class="o">*</span> <span class="n">dx</span><span class="p">)</span> <span class="k">...</span>
                      <span class="o">+</span> <span class="p">(</span><span class="n">v</span><span class="p">([</span><span class="mi">2</span><span class="p">:</span><span class="k">end</span><span class="p">,</span> <span class="k">end</span><span class="p">],</span> <span class="p">:)</span> <span class="o">-</span> <span class="n">v</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">:</span><span class="k">end</span><span class="o">-</span><span class="mi">1</span><span class="p">],</span> <span class="p">:))</span> <span class="p">/</span> <span class="p">(</span><span class="mi">2</span> <span class="o">*</span> <span class="n">dy</span><span class="p">))</span> <span class="k">...</span>
            <span class="o">+</span> <span class="n">dt</span> <span class="o">*</span> <span class="n">mu</span> <span class="o">*</span> <span class="p">((</span><span class="n">v</span><span class="p">(:,</span> <span class="p">[</span><span class="mi">2</span><span class="p">:</span><span class="k">end</span><span class="p">,</span> <span class="k">end</span><span class="p">])</span> <span class="o">-</span> <span class="mi">2</span><span class="o">*</span><span class="n">v</span> <span class="o">+</span> <span class="n">v</span><span class="p">(:,</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">:</span><span class="k">end</span><span class="o">-</span><span class="mi">1</span><span class="p">]))</span> <span class="p">/</span> <span class="n">dx</span><span class="o">^</span><span class="mi">2</span> <span class="k">...</span>
                      <span class="o">+</span> <span class="p">(</span><span class="n">v</span><span class="p">([</span><span class="mi">2</span><span class="p">:</span><span class="k">end</span><span class="p">,</span> <span class="k">end</span><span class="p">],</span> <span class="p">:)</span> <span class="o">-</span> <span class="mi">2</span><span class="o">*</span><span class="n">v</span> <span class="o">+</span> <span class="n">v</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">:</span><span class="k">end</span><span class="o">-</span><span class="mi">1</span><span class="p">],</span> <span class="p">:))</span> <span class="p">/</span> <span class="n">dy</span><span class="o">^</span><span class="mi">2</span><span class="p">);</span>

    <span class="c1">% Apply boundary conditions</span>
    <span class="n">u_new</span><span class="p">(:,</span> <span class="mi">1</span><span class="p">)</span> <span class="o">=</span> <span class="n">U</span><span class="p">;</span>  
    <span class="n">u_new</span><span class="p">(:,</span> <span class="k">end</span><span class="p">)</span> <span class="o">=</span> <span class="n">u_new</span><span class="p">(:,</span> <span class="k">end</span><span class="o">-</span><span class="mi">1</span><span class="p">);</span> 
    <span class="n">v_new</span><span class="p">(:,</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="k">end</span><span class="p">])</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> 

    <span class="c1">% No-slip condition at cylinder</span>
    <span class="n">u_new</span><span class="p">(</span><span class="n">cylinder_mask</span><span class="p">)</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="n">v_new</span><span class="p">(</span><span class="n">cylinder_mask</span><span class="p">)</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

    <span class="c1">% Pressure correction using central difference</span>
    <span class="n">p_new</span> <span class="o">=</span> <span class="n">p</span> <span class="o">-</span> <span class="n">dt</span> <span class="o">*</span> <span class="n">rho</span> <span class="o">*</span> <span class="p">((</span><span class="n">p</span><span class="p">(:,</span> <span class="p">[</span><span class="mi">2</span><span class="p">:</span><span class="k">end</span><span class="p">,</span> <span class="k">end</span><span class="p">])</span> <span class="o">-</span> <span class="mi">2</span><span class="o">*</span><span class="n">p</span> <span class="o">+</span> <span class="n">p</span><span class="p">(:,</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">:</span><span class="k">end</span><span class="o">-</span><span class="mi">1</span><span class="p">]))</span> <span class="p">/</span> <span class="n">dx</span><span class="o">^</span><span class="mi">2</span> <span class="k">...</span>
                          <span class="o">+</span> <span class="p">(</span><span class="n">p</span><span class="p">([</span><span class="mi">2</span><span class="p">:</span><span class="k">end</span><span class="p">,</span> <span class="k">end</span><span class="p">],</span> <span class="p">:)</span> <span class="o">-</span> <span class="mi">2</span><span class="o">*</span><span class="n">p</span> <span class="o">+</span> <span class="n">p</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">:</span><span class="k">end</span><span class="o">-</span><span class="mi">1</span><span class="p">],</span> <span class="p">:))</span> <span class="p">/</span> <span class="n">dy</span><span class="o">^</span><span class="mi">2</span><span class="p">);</span>

    <span class="c1">% Update fields</span>
    <span class="n">u</span> <span class="o">=</span> <span class="n">u_new</span><span class="p">;</span>
    <span class="n">v</span> <span class="o">=</span> <span class="n">v_new</span><span class="p">;</span>
    <span class="n">p</span> <span class="o">=</span> <span class="n">p_new</span><span class="p">;</span>

    <span class="c1">% Monitor convergence</span>
    <span class="k">if</span> <span class="nb">mod</span><span class="p">(</span><span class="n">iter</span><span class="p">,</span> <span class="mi">100</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span>
        <span class="nb">fprintf</span><span class="p">(</span><span class="s1">'Iteration %d\n'</span><span class="p">,</span> <span class="n">iter</span><span class="p">);</span>
    <span class="k">end</span>
<span class="k">end</span>
</code></pre></div></div> <hr/> <h2 id="drag-coefficient-calculation">Drag Coefficient Calculation</h2> <p>We’ll now compute the drag force and determine the drag coefficient:</p> <div class="language-matlab highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">% Compute drag force components</span>
<span class="n">fx</span> <span class="o">=</span> <span class="o">-</span><span class="nb">trapz</span><span class="p">(</span><span class="n">y</span><span class="p">,</span> <span class="n">p</span><span class="p">(:,</span> <span class="nb">round</span><span class="p">(</span><span class="n">Nx</span><span class="p">/</span><span class="mi">2</span><span class="p">)));</span>  <span class="c1">% Pressure force contribution</span>
<span class="n">tau_wall</span> <span class="o">=</span> <span class="n">mu</span> <span class="o">*</span> <span class="p">(</span><span class="n">u</span><span class="p">(:,</span> <span class="nb">round</span><span class="p">(</span><span class="n">Nx</span><span class="p">/</span><span class="mi">2</span><span class="p">))</span> <span class="o">-</span> <span class="mi">0</span><span class="p">)</span> <span class="p">/</span> <span class="n">dx</span><span class="p">;</span> <span class="c1">% Shear stress at the wall</span>
<span class="n">fv</span> <span class="o">=</span> <span class="nb">trapz</span><span class="p">(</span><span class="n">y</span><span class="p">,</span> <span class="n">tau_wall</span><span class="p">);</span>  <span class="c1">% Viscous force contribution</span>

<span class="c1">% Total drag force</span>
<span class="n">Fd</span> <span class="o">=</span> <span class="n">fx</span> <span class="o">+</span> <span class="n">fv</span><span class="p">;</span>

<span class="c1">% Drag coefficient calculation</span>
<span class="n">A</span> <span class="o">=</span> <span class="n">D</span><span class="p">;</span> <span class="c1">% Projected area for 2D cylinder</span>
<span class="n">Cd</span> <span class="o">=</span> <span class="n">Fd</span> <span class="p">/</span> <span class="p">(</span><span class="mf">0.5</span> <span class="o">*</span> <span class="n">rho</span> <span class="o">*</span> <span class="n">U</span><span class="o">^</span><span class="mi">2</span> <span class="o">*</span> <span class="n">A</span><span class="p">);</span>

<span class="nb">fprintf</span><span class="p">(</span><span class="s1">'Drag Coefficient (Cd): %.4f\n'</span><span class="p">,</span> <span class="n">Cd</span><span class="p">);</span>
</code></pre></div></div> <hr/> <h2 id="post-processing-and-visualization">Post Processing and Visualization</h2> <p>Finally, we’ll visualize the results with velocity magnitude contours and streamlines.</p> <h3 id="velocity-contour-plot">Velocity Contour Plot</h3> <div class="language-matlab highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nb">figure</span><span class="p">;</span>
<span class="nb">contourf</span><span class="p">(</span><span class="n">X</span><span class="p">,</span> <span class="n">Y</span><span class="p">,</span> <span class="nb">sqrt</span><span class="p">(</span><span class="n">u</span><span class="o">.^</span><span class="mi">2</span> <span class="o">+</span> <span class="n">v</span><span class="o">.^</span><span class="mi">2</span><span class="p">),</span> <span class="mi">20</span><span class="p">);</span>
<span class="nb">colorbar</span><span class="p">;</span>
<span class="nb">title</span><span class="p">(</span><span class="s1">'Velocity Magnitude Contour'</span><span class="p">);</span>
<span class="nb">xlabel</span><span class="p">(</span><span class="s1">'X'</span><span class="p">);</span>
<span class="nb">ylabel</span><span class="p">(</span><span class="s1">'Y'</span><span class="p">);</span>
<span class="nb">axis</span> <span class="n">equal</span><span class="p">;</span>
</code></pre></div></div> <h3 id="streamline-plot">Streamline Plot</h3> <div class="language-matlab highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nb">figure</span><span class="p">;</span>
<span class="nb">quiver</span><span class="p">(</span><span class="n">X</span><span class="p">,</span> <span class="n">Y</span><span class="p">,</span> <span class="n">u</span><span class="p">,</span> <span class="n">v</span><span class="p">);</span>
<span class="nb">title</span><span class="p">(</span><span class="s1">'Velocity Field'</span><span class="p">);</span>
<span class="nb">xlabel</span><span class="p">(</span><span class="s1">'X'</span><span class="p">);</span>
<span class="nb">ylabel</span><span class="p">(</span><span class="s1">'Y'</span><span class="p">);</span>
<span class="nb">axis</span> <span class="n">equal</span><span class="p">;</span>
</code></pre></div></div> <hr/> <h2 id="results-and-comparison">Results and Comparison</h2> <p>For low Reynolds numbers, the analytical drag coefficient for a 2D cylinder is:</p> <p>[ C_d = \frac{8\pi}{\text{Re}} ]</p> <p>Let’s compare our computed drag coefficient with the analytical value:</p> <div class="language-matlab highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">Cd_analytical</span> <span class="o">=</span> <span class="mi">8</span> <span class="o">*</span> <span class="nb">pi</span> <span class="p">/</span> <span class="n">Re</span><span class="p">;</span>
<span class="nb">fprintf</span><span class="p">(</span><span class="s1">'Analytical Drag Coefficient: %.4f\n'</span><span class="p">,</span> <span class="n">Cd_analytical</span><span class="p">);</span>
<span class="nb">fprintf</span><span class="p">(</span><span class="s1">'Error: %.2f%%\n'</span><span class="p">,</span> <span class="nb">abs</span><span class="p">(</span><span class="n">Cd</span> <span class="o">-</span> <span class="n">Cd_analytical</span><span class="p">)</span> <span class="p">/</span> <span class="n">Cd_analytical</span> <span class="o">*</span> <span class="mi">100</span><span class="p">);</span>
</code></pre></div></div> <h2 id="further-improvements">Further Improvements</h2> <p>To enhance this model, consider:</p> <ul> <li>Refining the grid resolution for better accuracy.</li> <li>Implementing higher-order numerical schemes.</li> <li>Extending to 3D simulations.</li> </ul> <hr/> <p>I hope you found this tutorial helpful. Feel free to try it out and experiment with different parameters!</p>]]></content><author><name></name></author><category term="computational"/><category term="dynamics"/><summary type="html"><![CDATA[Simulating Flow Over a Cylinder Using MATLAB and the Lattice Boltzmann Methoe]]></summary></entry><entry><title type="html">Integral Table</title><link href="https://coltonkawamura.github.io/coltonkawamura/blog/2023/integral-table/" rel="alternate" type="text/html" title="Integral Table"/><published>2023-04-24T16:40:16+00:00</published><updated>2023-04-24T16:40:16+00:00</updated><id>https://coltonkawamura.github.io/coltonkawamura/blog/2023/integral-table</id><content type="html" xml:base="https://coltonkawamura.github.io/coltonkawamura/blog/2023/integral-table/"><![CDATA[\[\int A x^2 \sin^2(kx) \, dx = \frac{A}{6} x^3 - \frac{A}{4k^2} x^2 \sin(2kx) - \frac{A}{4k^3} x \cos(2kx) + \frac{A}{8k^3} \sin(2kx) + C.\] <p><strong>Definite Integrals</strong></p> \[\int_0^\pi \cos^2(x) \, dx = \frac{\pi}{2}\] <p>The area under \(\cos\) and \(\cos^2\) is \(\pi\) times the amplitude. Since our amplitude is only \(1\) and the range is only have of a full cycle, the area under is \(\pi/2\). So for a full cycle, it should be twice a half-cycle, or \(\pi\), so,</p> \[\int_0^{2\pi} \cos^2(x) \, dx=\pi.\]]]></content><author><name></name></author><category term="math"/><category term="integrals"/><summary type="html"><![CDATA[Integrals that I look up way too often.]]></summary></entry><entry><title type="html">Classical Mechanics References</title><link href="https://coltonkawamura.github.io/coltonkawamura/blog/2023/classical-mechanics-references/" rel="alternate" type="text/html" title="Classical Mechanics References"/><published>2023-03-20T18:37:00+00:00</published><updated>2023-03-20T18:37:00+00:00</updated><id>https://coltonkawamura.github.io/coltonkawamura/blog/2023/classical-mechanics-references</id><content type="html" xml:base="https://coltonkawamura.github.io/coltonkawamura/blog/2023/classical-mechanics-references/"><![CDATA[<h3 id="lagrangian">Lagrangian</h3> \[\frac{d}{dt} \left( \frac{\partial L}{\partial \dot{q}_j} \right) = \frac{\partial L}{\partial q_j}\] <p>which is just newton’s second law</p> \[m \ddot{q}_j= -\nabla U(q)\]]]></content><author><name></name></author><category term="physics"/><category term="classical"/><summary type="html"><![CDATA[My most used classical mechanics references.]]></summary></entry><entry><title type="html">Matrix Operations</title><link href="https://coltonkawamura.github.io/coltonkawamura/blog/2023/matrix-operations/" rel="alternate" type="text/html" title="Matrix Operations"/><published>2023-03-20T15:59:00+00:00</published><updated>2023-03-20T15:59:00+00:00</updated><id>https://coltonkawamura.github.io/coltonkawamura/blog/2023/matrix-operations</id><content type="html" xml:base="https://coltonkawamura.github.io/coltonkawamura/blog/2023/matrix-operations/"><![CDATA[<h2 id="cross-product-of-two-vectors">Cross Product of Two Vectors</h2> <p>Given two vectors:</p> \[\mathbf{A} = \begin{bmatrix} a \\ b \\ c \end{bmatrix}, \quad \mathbf{B} = \begin{bmatrix} d \\ e \\ f \end{bmatrix}\] <p>The cross product $\mathbf{A} \times \mathbf{B}$ is given by the determinant of a 3x3 matrix:</p> \[\mathbf{A} \times \mathbf{B} = \begin{vmatrix} \hat{i} &amp; \hat{j} &amp; \hat{k} \\ a &amp; b &amp; c \\ d &amp; e &amp; f \end{vmatrix}\] <h3 id="components">Components:</h3> <ul> <li> <p><strong>X-component</strong>: \(\hat{i} \cdot \begin{vmatrix} b &amp; c \\ e &amp; f \end{vmatrix} = bf - ce\)</p> </li> <li> <p><strong>Y-component</strong>: \(-\hat{j} \cdot \begin{vmatrix} a &amp; c \\ d &amp; f \end{vmatrix} = -(af - cd)\)</p> </li> <li> <p><strong>Z-component</strong>: \(\hat{k} \cdot \begin{vmatrix} a &amp; b \\ d &amp; e \end{vmatrix} = ae - bd\)</p> </li> </ul> <h3 id="resulting-vector">Resulting Vector:</h3> \[\mathbf{A} \times \mathbf{B} = \left( bf - ce, -(af - cd), ae - bd \right)\] <h2 id="determinant">Determinant</h2> \[A = \begin{bmatrix} a &amp; b &amp; c \\ d &amp; e &amp; f \\ g &amp; h &amp; i \end{bmatrix}\] \[\text{det}(A) = a(ei - fh) - b(di - fg) + c(dh - eg)\]]]></content><author><name></name></author><category term="math"/><category term="matrix"/><summary type="html"><![CDATA[A references for matrix operations that I use often.]]></summary></entry><entry><title type="html">Electrodynamics References</title><link href="https://coltonkawamura.github.io/coltonkawamura/blog/2022/electrodynamics-references/" rel="alternate" type="text/html" title="Electrodynamics References"/><published>2022-12-10T15:59:00+00:00</published><updated>2022-12-10T15:59:00+00:00</updated><id>https://coltonkawamura.github.io/coltonkawamura/blog/2022/electrodynamics-references</id><content type="html" xml:base="https://coltonkawamura.github.io/coltonkawamura/blog/2022/electrodynamics-references/"><![CDATA[<h2 id="maxwells-equations">Maxwell’s Equations</h2> <h3 id="in-general">In General:</h3> \[\begin{aligned} \nabla \cdot \mathbf{E} &amp;= \frac{1}{\epsilon_0} \rho \\ \\ \nabla \times \mathbf{E} &amp;= -\frac{\partial \mathbf{B}}{\partial t} \\ \\ \nabla \cdot \mathbf{B} &amp;= 0 \\ \\ \nabla \times \mathbf{B} &amp;= \mu_0 \mathbf{J} + \mu_0 \epsilon_0 \frac{\partial \mathbf{E}}{\partial t} \end{aligned}\] <h3 id="in-matter">In Matter:</h3> \[\begin{aligned} \nabla \cdot \mathbf{D} &amp;= \rho_f \\ \\ \nabla \times \mathbf{E} &amp;= -\frac{\partial \mathbf{B}}{\partial t} \\ \\ \nabla \cdot \mathbf{B} &amp;= 0 \\ \\ \nabla \times \mathbf{H} &amp;= \mathbf{J}_f + \frac{\partial \mathbf{D}}{\partial t} \end{aligned}\] <h2 id="auxillary-fields">Auxillary Fields:</h2> \[\mathbf{D} = \epsilon_0 \mathbf{E} + \mathbf{P}\] \[\mathbf{H} = \frac{1}{\mu_0} \mathbf{B} - \mathbf{M}\] <p>In Linear Media:</p> \[\mathbf{P} = \epsilon_0 \chi_e \mathbf{E}, \quad \mathbf{D} = \epsilon \mathbf{E}\] \[\mathbf{M} = \chi_m \mathbf{H}, \quad \mathbf{H} = \frac{1}{\mu} \mathbf{B}\] <h2 id="potentials">Potentials</h2> \[\mathbf{E} = -\nabla V - \frac{\partial \mathbf{A}}{\partial t}, \quad \mathbf{B} = \nabla \times \mathbf{A}\] <h2 id="lorentz-force-law">Lorentz Force Law</h2> \[\mathbf{F} = q (\mathbf{E} + \mathbf{v} \times \mathbf{B})\] <h2 id="energy-momentum-and-power">Energy, Momentum, and Power</h2> <p>Energy: \(\quad U = \frac{1}{2} \int \left( \epsilon_0 E^2 + \frac{1}{\mu_0} B^2 \right) d\tau\)</p> <p>Momentum: \(\quad \mathbf{P} = \epsilon_0 \int (\mathbf{E} \times \mathbf{B}) \, d\tau\)</p> <p>Poynting Vector (Power per Area): \(\quad \mathbf{S} = \frac{1}{\mu_0} (\mathbf{E} \times \mathbf{B})\)</p> <p>Larmor: \(\quad P = \frac{\mu_0}{6 \pi c} q^2 a^2\)</p>]]></content><author><name></name></author><category term="physics"/><category term="electrodynamics"/><summary type="html"><![CDATA[My most used Electrodynamics references.]]></summary></entry><entry><title type="html">Vector Identities</title><link href="https://coltonkawamura.github.io/coltonkawamura/blog/2022/vector-identities/" rel="alternate" type="text/html" title="Vector Identities"/><published>2022-02-01T17:39:00+00:00</published><updated>2022-02-01T17:39:00+00:00</updated><id>https://coltonkawamura.github.io/coltonkawamura/blog/2022/vector-identities</id><content type="html" xml:base="https://coltonkawamura.github.io/coltonkawamura/blog/2022/vector-identities/"><![CDATA[<h3 id="triple-products">Triple Products</h3> \[\mathbf{A} \cdot (\mathbf{B} \times \mathbf{C}) = \mathbf{B} \cdot (\mathbf{C} \times \mathbf{A}) = \mathbf{C} \cdot (\mathbf{A} \times \mathbf{B})\] \[\mathbf{A} \times (\mathbf{B} \times \mathbf{C}) = \mathbf{B}(\mathbf{A} \cdot \mathbf{C}) - \mathbf{C}(\mathbf{A} \cdot \mathbf{B})\] <h3 id="product-rules">Product Rules</h3> \[\begin{aligned} \nabla (fg) &amp;= f (\nabla g) + g (\nabla f) \\ \\ \nabla (\mathbf{A} \cdot \mathbf{B}) &amp;= \mathbf{A} \times (\nabla \times \mathbf{B}) + \mathbf{B} \times (\nabla \times \mathbf{A}) + (\mathbf{A} \cdot \nabla) \mathbf{B} + (\mathbf{B} \cdot \nabla) \mathbf{A} \\ \\ \nabla \cdot (f \mathbf{A}) &amp;= f (\nabla \cdot \mathbf{A}) + \mathbf{A} \cdot (\nabla f) \\ \\ \nabla \cdot (\mathbf{A} \times \mathbf{B}) &amp;= \mathbf{B} \cdot (\nabla \times \mathbf{A}) - \mathbf{A} \cdot (\nabla \times \mathbf{B}) \\ \\ \nabla \times (f \mathbf{A}) &amp;= f (\nabla \times \mathbf{A}) - \mathbf{A} \times (\nabla f) \\ \\ \nabla \times (\mathbf{A} \times \mathbf{B}) &amp;= (\mathbf{B} \cdot \nabla) \mathbf{A} - (\mathbf{A} \cdot \nabla) \mathbf{B} - \mathbf{B} (\nabla \cdot \mathbf{A}) + \mathbf{A} (\nabla \cdot \mathbf{B}) \end{aligned}\] <h3 id="second-derivatives">Second Derivatives</h3> \[\begin{aligned} \nabla \cdot (\nabla \times \mathbf{A}) &amp;= 0 \\ \\ \nabla \times (\nabla f) &amp;= 0 \\ \\ \nabla \times (\nabla \times \mathbf{A}) &amp;= \nabla (\nabla \cdot \mathbf{A}) - \nabla^2 \mathbf{A} \end{aligned}\] <h3 id="fundamental-theorems">Fundamental Theorems</h3> <p>Gradient Theorem: \(\quad \int_a^b (\nabla f) \cdot d\mathbf{l} = f(b) - f(a)\)</p> <p>Divergence Theorem: \(\quad \int (\nabla \cdot \mathbf{A}) \, d\tau = \oint \mathbf{A} \cdot d\mathbf{a}\)</p> <p>Curl Theorem: \(\quad \int (\nabla \times \mathbf{A}) \cdot d\mathbf{a} = \oint \mathbf{A} \cdot d\mathbf{l}\)</p>]]></content><author><name></name></author><category term="math"/><category term="derivatives"/><summary type="html"><![CDATA[My most used vector identities]]></summary></entry><entry><title type="html">Vector Derivatives</title><link href="https://coltonkawamura.github.io/coltonkawamura/blog/2021/vector-derivatives/" rel="alternate" type="text/html" title="Vector Derivatives"/><published>2021-07-04T17:39:00+00:00</published><updated>2021-07-04T17:39:00+00:00</updated><id>https://coltonkawamura.github.io/coltonkawamura/blog/2021/vector-derivatives</id><content type="html" xml:base="https://coltonkawamura.github.io/coltonkawamura/blog/2021/vector-derivatives/"><![CDATA[<h3 id="cartesian">Cartesian</h3> \[\begin{aligned} \text{Cartesian:} \quad dl &amp;= dx \, \hat{x} + dy \, \hat{y} + dz \, \hat{z}; \quad d\tau = dx \, dy \, dz \\ \\ \text{Gradient:} \quad \nabla t &amp;= \frac{\partial t}{\partial x} \, \hat{x} + \frac{\partial t}{\partial y} \, \hat{y} + \frac{\partial t}{\partial z} \, \hat{z} \\ \\ \text{Divergence:} \quad \nabla \cdot \mathbf{v} &amp;= \frac{\partial v_x}{\partial x} + \frac{\partial v_y}{\partial y} + \frac{\partial v_z}{\partial z} \\ \\ \text{Curl:} \quad \nabla \times \mathbf{v} &amp;= \left( \frac{\partial v_z}{\partial y} - \frac{\partial v_y}{\partial z} \right) \, \hat{x} + \left( \frac{\partial v_x}{\partial z} - \frac{\partial v_z}{\partial x} \right) \, \hat{y} + \left( \frac{\partial v_y}{\partial x} - \frac{\partial v_x}{\partial y} \right) \, \hat{z} \\ \\ \text{Laplacian:} \quad \nabla^2 t &amp;= \frac{\partial^2 t}{\partial x^2} + \frac{\partial^2 t}{\partial y^2} + \frac{\partial^2 t}{\partial z^2} \end{aligned}\] <h3 id="spherical">Spherical</h3> \[\begin{aligned} \text{Spherical:} \quad dl &amp;= dr \, \hat{r} + r \, d\theta \, \hat{\theta} + r \sin{\theta} \, d\phi \, \hat{\phi}; \quad d\tau = r^2 \sin{\theta} \, dr \, d\theta \, d\phi \\ \\ \text{Gradient:} \quad \nabla t &amp;= \frac{\partial t}{\partial r} \, \hat{r} + \frac{1}{r} \frac{\partial t}{\partial \theta} \, \hat{\theta} + \frac{1}{r \sin{\theta}} \frac{\partial t}{\partial \phi} \, \hat{\phi} \\ \\ \text{Divergence:} \quad \nabla \cdot \mathbf{v} &amp;= \frac{1}{r^2} \frac{\partial}{\partial r} \left( r^2 v_r \right) + \frac{1}{r \sin{\theta}} \frac{\partial}{\partial \theta} \left( \sin{\theta} v_\theta \right) + \frac{1}{r \sin{\theta}} \frac{\partial v_\phi}{\partial \phi} \\ \\ \text{Curl:} \quad \nabla \times \mathbf{v} &amp;= \frac{1}{r \sin{\theta}} \left[ \frac{\partial}{\partial \theta} \left( \sin{\theta} v_\phi \right) - \frac{\partial v_\theta}{\partial \phi} \right] \, \hat{r} \\ &amp;+ \frac{1}{r} \left[ \frac{1}{\sin{\theta}} \frac{\partial v_r}{\partial \phi} - \frac{\partial}{\partial r} \left( r v_\phi \right) \right] \, \hat{\theta} \\ &amp;+ \frac{1}{r} \left[ \frac{\partial}{\partial r} \left( r v_\theta \right) - \frac{\partial v_r}{\partial \theta} \right] \, \hat{\phi} \\ \\ \text{Laplacian:} \quad \nabla^2 t &amp;= \frac{1}{r^2} \frac{\partial}{\partial r} \left( r^2 \frac{\partial t}{\partial r} \right) + \frac{1}{r^2 \sin{\theta}} \frac{\partial}{\partial \theta} \left( \sin{\theta} \frac{\partial t}{\partial \theta} \right) + \frac{1}{r^2 \sin^2{\theta}} \frac{\partial^2 t}{\partial \phi^2} \end{aligned}\] <h3 id="cylindrical">Cylindrical</h3> \[\begin{aligned} \text{Cylindrical:} \quad dl &amp;= ds \, \hat{s} + s \, d\phi \, \hat{\phi} + dz \, \hat{z}; \quad d\tau = s \, ds \, d\phi \, dz \\ \\ \text{Gradient:} \quad \nabla t &amp;= \frac{\partial t}{\partial s} \, \hat{s} + \frac{1}{s} \frac{\partial t}{\partial \phi} \, \hat{\phi} + \frac{\partial t}{\partial z} \, \hat{z} \\ \\ \text{Divergence:} \quad \nabla \cdot \mathbf{v} &amp;= \frac{1}{s} \frac{\partial}{\partial s} \left( s v_s \right) + \frac{1}{s} \frac{\partial v_\phi}{\partial \phi} + \frac{\partial v_z}{\partial z} \\ \\ \text{Curl:} \quad \nabla \times \mathbf{v} &amp;= \left[ \frac{1}{s} \frac{\partial v_z}{\partial \phi} - \frac{\partial v_\phi}{\partial z} \right] \, \hat{s} + \left[ \frac{\partial v_s}{\partial z} - \frac{\partial v_z}{\partial s} \right] \, \hat{\phi} \\ &amp;+ \frac{1}{s} \left[ \frac{\partial}{\partial s} \left( s v_\phi \right) - \frac{\partial v_s}{\partial \phi} \right] \, \hat{z} \\ \\ \text{Laplacian:} \quad \nabla^2 t &amp;= \frac{1}{s} \frac{\partial}{\partial s} \left( s \frac{\partial t}{\partial s} \right) + \frac{1}{s^2} \frac{\partial^2 t}{\partial \phi^2} + \frac{\partial^2 t}{\partial z^2} \end{aligned}\]]]></content><author><name></name></author><category term="math"/><category term="derivatives"/><summary type="html"><![CDATA[My most used vector derivatives.]]></summary></entry></feed>