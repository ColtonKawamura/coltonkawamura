<?xml version="1.0" encoding="utf-8"?><feed xmlns="http://www.w3.org/2005/Atom" xml:lang="en"><generator uri="https://jekyllrb.com/" version="4.3.3">Jekyll</generator><link href="https://coltonkawamura.github.io/coltonkawamura/feed.xml" rel="self" type="application/atom+xml"/><link href="https://coltonkawamura.github.io/coltonkawamura/" rel="alternate" type="text/html" hreflang="en"/><updated>2025-02-04T14:56:00+00:00</updated><id>https://coltonkawamura.github.io/coltonkawamura/feed.xml</id><title type="html">blank</title><subtitle></subtitle><entry><title type="html">How to Combine Two Plots in Matlab</title><link href="https://coltonkawamura.github.io/coltonkawamura/blog/2024/combine-two-figures-matlab/" rel="alternate" type="text/html" title="How to Combine Two Plots in Matlab"/><published>2024-05-01T00:32:13+00:00</published><updated>2024-05-01T00:32:13+00:00</updated><id>https://coltonkawamura.github.io/coltonkawamura/blog/2024/combine-two-figures-matlab</id><content type="html" xml:base="https://coltonkawamura.github.io/coltonkawamura/blog/2024/combine-two-figures-matlab/"><![CDATA[<p>Just replace your two figures for <code class="language-plaintext highlighter-rouge">f1</code> and <code class="language-plaintext highlighter-rouge">f2</code>.</p> <div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>% Define the two figure files that are on the MATLAB path
% These are the only <span class="s2">"inputs"</span> to this script
f1 <span class="o">=</span> <span class="s1">'fig1.fig'</span><span class="p">;</span>
f2 <span class="o">=</span> <span class="s1">'fig2.fig'</span><span class="p">;</span>

% Open the figures
fig1 <span class="o">=</span> openfig<span class="o">(</span>f1<span class="o">)</span><span class="p">;</span>
fig2 <span class="o">=</span> openfig<span class="o">(</span>f2<span class="o">)</span><span class="p">;</span>

% get axes handles - this assumes there is only 1 axes per figure!
fig1ax <span class="o">=</span> gca<span class="o">(</span>fig1<span class="o">)</span><span class="p">;</span>
fig2ax <span class="o">=</span> gca<span class="o">(</span>fig2<span class="o">)</span><span class="p">;</span>
leg1 <span class="o">=</span> findobj<span class="o">(</span>fig1,<span class="s1">'Type'</span>,<span class="s1">'legend'</span><span class="o">)</span><span class="p">;</span>
leg2 <span class="o">=</span> findobj<span class="o">(</span>fig2,<span class="s1">'Type'</span>,<span class="s1">'legend'</span><span class="o">)</span><span class="p">;</span>

% Get axis children
fig1axChildren <span class="o">=</span> get<span class="o">(</span>fig1ax,<span class="s1">'Children'</span><span class="o">)</span><span class="p">;</span>
fig2axChildren <span class="o">=</span> get<span class="o">(</span>fig2ax,<span class="s1">'Children'</span><span class="o">)</span><span class="p">;</span>

% Create new fig, copy items from fig 1
% This will maintain <span class="nb">set </span>properties such as color
figFinal <span class="o">=</span> figure<span class="o">()</span><span class="p">;</span>
ax <span class="o">=</span> axes<span class="o">(</span>figFinal<span class="o">)</span><span class="p">;</span>
h1 <span class="o">=</span> copyobj<span class="o">(</span>fig1axChildren, ax<span class="o">)</span><span class="p">;</span>


% Copy items from fig 2
h2 <span class="o">=</span> copyobj<span class="o">(</span>fig2axChildren, ax<span class="o">)</span><span class="p">;</span>
<span class="nb">set</span><span class="o">(</span>gca, <span class="s1">'YScale'</span>, <span class="s1">'log'</span><span class="o">)</span>
<span class="nb">set</span><span class="o">(</span>gca, <span class="s1">'XScale'</span>, <span class="s1">'log'</span><span class="o">)</span>
grid on


% Add legend to same location as the legend <span class="k">in </span>fig2 
% but only include objects with a defined DisplayName
h <span class="o">=</span> <span class="o">[</span>h2<span class="p">;</span>h1]<span class="p">;</span>
hasDisplayName <span class="o">=</span> ~cellfun<span class="o">(</span><span class="s1">'isempty'</span>,get<span class="o">(</span>h,<span class="s1">'DisplayName'</span><span class="o">))</span><span class="p">;</span>
legend<span class="o">(</span>ax, h<span class="o">(</span>hasDisplayName<span class="o">)</span>,<span class="s1">'Location'</span>, leg1.Location, <span class="s1">'Interpreter'</span>, <span class="s1">'Latex'</span><span class="o">)</span>


% Copy axis labels
xlabel<span class="o">(</span>ax, fig2ax.XLabel.String, <span class="s1">'Interpreter'</span>, <span class="s1">'Latex'</span>, <span class="s1">'FontSize'</span>, 20<span class="o">)</span>
ylabel<span class="o">(</span>ax, fig2ax.YLabel.String, <span class="s1">'Interpreter'</span>, <span class="s1">'Latex'</span>, <span class="s1">'FontSize'</span>, 20<span class="o">)</span>
<span class="nb">set</span><span class="o">(</span>get<span class="o">(</span>gca, <span class="s1">'ylabel'</span><span class="o">)</span>, <span class="s1">'rotation'</span>, 0<span class="o">)</span><span class="p">;</span>
</code></pre></div></div>]]></content><author><name></name></author><category term="computing"/><category term="matlab"/><summary type="html"><![CDATA[How to Combine Two Figures in Matlab Including all the Data.]]></summary></entry><entry><title type="html">Drag Coefficent in 2D in Matlab</title><link href="https://coltonkawamura.github.io/coltonkawamura/blog/2024/cfd/" rel="alternate" type="text/html" title="Drag Coefficent in 2D in Matlab"/><published>2024-04-29T23:36:10+00:00</published><updated>2024-04-29T23:36:10+00:00</updated><id>https://coltonkawamura.github.io/coltonkawamura/blog/2024/cfd</id><content type="html" xml:base="https://coltonkawamura.github.io/coltonkawamura/blog/2024/cfd/"><![CDATA[<h1 id="simulating-flow-over-a-cylinder-using-matlab-and-the-lattice-boltzmann-method">Simulating Flow Over a Cylinder Using MATLAB and the Lattice Boltzmann Method</h1> <h2 id="introduction">Introduction</h2> <p>Computational Fluid Dynamics (CFD) is a powerful tool used to analyze fluid flow problems. In this tutorial, we’ll simulate <strong>2D flow past a cylinder</strong> using <strong>MATLAB</strong> and the <strong>Lattice Boltzmann Method (LBM)</strong> to compute the drag coefficient. We’ll also visualize velocity fields and streamline patterns.</p> <hr/> <h2 id="problem-setup">Problem Setup</h2> <p>We’ll analyze the flow past a cylinder with the following parameters:</p> <div class="language-matlab highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">% Problem Parameters</span>
<span class="n">D</span> <span class="o">=</span> <span class="mf">1.0</span><span class="p">;</span>            <span class="c1">% Cylinder diameter (m)</span>
<span class="n">U</span> <span class="o">=</span> <span class="mf">1.0</span><span class="p">;</span>            <span class="c1">% Free-stream velocity (m/s)</span>
<span class="n">rho</span> <span class="o">=</span> <span class="mf">1.0</span><span class="p">;</span>          <span class="c1">% Fluid density (kg/m^3)</span>
<span class="n">mu</span> <span class="o">=</span> <span class="mf">0.01</span><span class="p">;</span>          <span class="c1">% Dynamic viscosity (Pa.s)</span>
<span class="n">Re</span> <span class="o">=</span> <span class="n">rho</span> <span class="o">*</span> <span class="n">U</span> <span class="o">*</span> <span class="n">D</span> <span class="p">/</span> <span class="n">mu</span><span class="p">;</span> <span class="c1">% Reynolds number</span>

<span class="c1">% Domain size</span>
<span class="n">Lx</span> <span class="o">=</span> <span class="mi">20</span><span class="p">;</span>  <span class="c1">% Length of domain in x-direction</span>
<span class="n">Ly</span> <span class="o">=</span> <span class="mi">10</span><span class="p">;</span>  <span class="c1">% Height of domain in y-direction</span>

<span class="nb">fprintf</span><span class="p">(</span><span class="s1">'Reynolds number: %.2f\n'</span><span class="p">,</span> <span class="n">Re</span><span class="p">);</span>
</code></pre></div></div> <p>The Reynolds number provides insight into flow characteristics, helping to determine if the flow is laminar or turbulent.</p> <hr/> <h2 id="mesh-generation">Mesh Generation</h2> <p>We’ll create a rectangular computational domain and place the cylinder at the center:</p> <div class="language-matlab highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">% Grid resolution</span>
<span class="n">Nx</span> <span class="o">=</span> <span class="mi">200</span><span class="p">;</span> <span class="c1">% Grid points in x-direction</span>
<span class="n">Ny</span> <span class="o">=</span> <span class="mi">100</span><span class="p">;</span> <span class="c1">% Grid points in y-direction</span>

<span class="n">x</span> <span class="o">=</span> <span class="nb">linspace</span><span class="p">(</span><span class="o">-</span><span class="n">Lx</span><span class="p">/</span><span class="mi">2</span><span class="p">,</span> <span class="n">Lx</span><span class="p">/</span><span class="mi">2</span><span class="p">,</span> <span class="n">Nx</span><span class="p">);</span>
<span class="n">y</span> <span class="o">=</span> <span class="nb">linspace</span><span class="p">(</span><span class="o">-</span><span class="n">Ly</span><span class="p">/</span><span class="mi">2</span><span class="p">,</span> <span class="n">Ly</span><span class="p">/</span><span class="mi">2</span><span class="p">,</span> <span class="n">Ny</span><span class="p">);</span>
<span class="p">[</span><span class="n">X</span><span class="p">,</span> <span class="n">Y</span><span class="p">]</span> <span class="o">=</span> <span class="nb">meshgrid</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">);</span>

<span class="c1">% Define cylinder boundary condition</span>
<span class="p">[</span><span class="n">theta</span><span class="p">,</span> <span class="n">r</span><span class="p">]</span> <span class="o">=</span> <span class="nb">cart2pol</span><span class="p">(</span><span class="n">X</span><span class="p">,</span> <span class="n">Y</span><span class="p">);</span>
<span class="n">cylinder_mask</span> <span class="o">=</span> <span class="n">r</span> <span class="o">&lt;</span> <span class="n">D</span><span class="p">/</span><span class="mi">2</span><span class="p">;</span>   <span class="c1">% Creates the surface mask</span>

<span class="c1">% Visualize the mesh</span>
<span class="nb">figure</span><span class="p">;</span>
<span class="nb">contourf</span><span class="p">(</span><span class="n">X</span><span class="p">,</span> <span class="n">Y</span><span class="p">,</span> <span class="nb">double</span><span class="p">(</span><span class="n">cylinder_mask</span><span class="p">),</span> <span class="p">[</span><span class="mf">0.5</span><span class="p">,</span> <span class="mf">0.5</span><span class="p">],</span> <span class="s1">'k'</span><span class="p">);</span>
<span class="nb">axis</span> <span class="n">equal</span><span class="p">;</span>
<span class="nb">title</span><span class="p">(</span><span class="s1">'Mesh and Cylinder Location'</span><span class="p">);</span>
<span class="nb">xlabel</span><span class="p">(</span><span class="s1">'X'</span><span class="p">);</span>
<span class="nb">ylabel</span><span class="p">(</span><span class="s1">'Y'</span><span class="p">);</span>
<span class="nb">grid</span> <span class="n">on</span><span class="p">;</span>
</code></pre></div></div> <hr/> <h2 id="solving-the-navier-stokes-equations-using-lattice-boltzmann-method">Solving the Navier-Stokes Equations Using Lattice Boltzmann Method</h2> <p>We’ll now solve the Navier-Stokes equations using the LBM approach with finite difference approximations.</p> <div class="language-matlab highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">% Initialize velocity and pressure fields</span>
<span class="n">u</span> <span class="o">=</span> <span class="nb">zeros</span><span class="p">(</span><span class="n">Ny</span><span class="p">,</span> <span class="n">Nx</span><span class="p">);</span>
<span class="n">v</span> <span class="o">=</span> <span class="nb">zeros</span><span class="p">(</span><span class="n">Ny</span><span class="p">,</span> <span class="n">Nx</span><span class="p">);</span>
<span class="n">p</span> <span class="o">=</span> <span class="nb">zeros</span><span class="p">(</span><span class="n">Ny</span><span class="p">,</span> <span class="n">Nx</span><span class="p">);</span>

<span class="n">dx</span> <span class="o">=</span> <span class="n">Lx</span> <span class="p">/</span> <span class="p">(</span><span class="n">Nx</span> <span class="o">-</span> <span class="mi">1</span><span class="p">);</span>
<span class="n">dy</span> <span class="o">=</span> <span class="n">Ly</span> <span class="p">/</span> <span class="p">(</span><span class="n">Ny</span> <span class="o">-</span> <span class="mi">1</span><span class="p">);</span>
<span class="n">dt</span> <span class="o">=</span> <span class="mf">0.01</span><span class="p">;</span>  <span class="c1">% Time step</span>

<span class="n">maxIter</span> <span class="o">=</span> <span class="mi">1000</span><span class="p">;</span>
<span class="k">for</span> <span class="n">iter</span> <span class="o">=</span> <span class="mi">1</span><span class="p">:</span><span class="n">maxIter</span>
    <span class="c1">% Compute velocity with central difference scheme</span>
    <span class="n">u_new</span> <span class="o">=</span> <span class="n">u</span> <span class="o">-</span> <span class="n">dt</span> <span class="o">*</span> <span class="p">((</span><span class="n">u</span><span class="p">(:,</span> <span class="p">[</span><span class="mi">2</span><span class="p">:</span><span class="k">end</span><span class="p">,</span> <span class="k">end</span><span class="p">])</span> <span class="o">-</span> <span class="n">u</span><span class="p">(:,</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">:</span><span class="k">end</span><span class="o">-</span><span class="mi">1</span><span class="p">]))</span> <span class="p">/</span> <span class="p">(</span><span class="mi">2</span> <span class="o">*</span> <span class="n">dx</span><span class="p">)</span> <span class="k">...</span>
                      <span class="o">+</span> <span class="p">(</span><span class="n">v</span><span class="p">([</span><span class="mi">2</span><span class="p">:</span><span class="k">end</span><span class="p">,</span> <span class="k">end</span><span class="p">],</span> <span class="p">:)</span> <span class="o">-</span> <span class="n">v</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">:</span><span class="k">end</span><span class="o">-</span><span class="mi">1</span><span class="p">],</span> <span class="p">:))</span> <span class="p">/</span> <span class="p">(</span><span class="mi">2</span> <span class="o">*</span> <span class="n">dy</span><span class="p">))</span> <span class="k">...</span>
            <span class="o">+</span> <span class="n">dt</span> <span class="o">*</span> <span class="n">mu</span> <span class="o">*</span> <span class="p">((</span><span class="n">u</span><span class="p">(:,</span> <span class="p">[</span><span class="mi">2</span><span class="p">:</span><span class="k">end</span><span class="p">,</span> <span class="k">end</span><span class="p">])</span> <span class="o">-</span> <span class="mi">2</span><span class="o">*</span><span class="n">u</span> <span class="o">+</span> <span class="n">u</span><span class="p">(:,</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">:</span><span class="k">end</span><span class="o">-</span><span class="mi">1</span><span class="p">]))</span> <span class="p">/</span> <span class="n">dx</span><span class="o">^</span><span class="mi">2</span> <span class="k">...</span>
                      <span class="o">+</span> <span class="p">(</span><span class="n">u</span><span class="p">([</span><span class="mi">2</span><span class="p">:</span><span class="k">end</span><span class="p">,</span> <span class="k">end</span><span class="p">],</span> <span class="p">:)</span> <span class="o">-</span> <span class="mi">2</span><span class="o">*</span><span class="n">u</span> <span class="o">+</span> <span class="n">u</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">:</span><span class="k">end</span><span class="o">-</span><span class="mi">1</span><span class="p">],</span> <span class="p">:))</span> <span class="p">/</span> <span class="n">dy</span><span class="o">^</span><span class="mi">2</span><span class="p">);</span>

    <span class="n">v_new</span> <span class="o">=</span> <span class="n">v</span> <span class="o">-</span> <span class="n">dt</span> <span class="o">*</span> <span class="p">((</span><span class="n">u</span><span class="p">(:,</span> <span class="p">[</span><span class="mi">2</span><span class="p">:</span><span class="k">end</span><span class="p">,</span> <span class="k">end</span><span class="p">])</span> <span class="o">-</span> <span class="n">u</span><span class="p">(:,</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">:</span><span class="k">end</span><span class="o">-</span><span class="mi">1</span><span class="p">]))</span> <span class="p">/</span> <span class="p">(</span><span class="mi">2</span> <span class="o">*</span> <span class="n">dx</span><span class="p">)</span> <span class="k">...</span>
                      <span class="o">+</span> <span class="p">(</span><span class="n">v</span><span class="p">([</span><span class="mi">2</span><span class="p">:</span><span class="k">end</span><span class="p">,</span> <span class="k">end</span><span class="p">],</span> <span class="p">:)</span> <span class="o">-</span> <span class="n">v</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">:</span><span class="k">end</span><span class="o">-</span><span class="mi">1</span><span class="p">],</span> <span class="p">:))</span> <span class="p">/</span> <span class="p">(</span><span class="mi">2</span> <span class="o">*</span> <span class="n">dy</span><span class="p">))</span> <span class="k">...</span>
            <span class="o">+</span> <span class="n">dt</span> <span class="o">*</span> <span class="n">mu</span> <span class="o">*</span> <span class="p">((</span><span class="n">v</span><span class="p">(:,</span> <span class="p">[</span><span class="mi">2</span><span class="p">:</span><span class="k">end</span><span class="p">,</span> <span class="k">end</span><span class="p">])</span> <span class="o">-</span> <span class="mi">2</span><span class="o">*</span><span class="n">v</span> <span class="o">+</span> <span class="n">v</span><span class="p">(:,</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">:</span><span class="k">end</span><span class="o">-</span><span class="mi">1</span><span class="p">]))</span> <span class="p">/</span> <span class="n">dx</span><span class="o">^</span><span class="mi">2</span> <span class="k">...</span>
                      <span class="o">+</span> <span class="p">(</span><span class="n">v</span><span class="p">([</span><span class="mi">2</span><span class="p">:</span><span class="k">end</span><span class="p">,</span> <span class="k">end</span><span class="p">],</span> <span class="p">:)</span> <span class="o">-</span> <span class="mi">2</span><span class="o">*</span><span class="n">v</span> <span class="o">+</span> <span class="n">v</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">:</span><span class="k">end</span><span class="o">-</span><span class="mi">1</span><span class="p">],</span> <span class="p">:))</span> <span class="p">/</span> <span class="n">dy</span><span class="o">^</span><span class="mi">2</span><span class="p">);</span>

    <span class="c1">% Apply boundary conditions</span>
    <span class="n">u_new</span><span class="p">(:,</span> <span class="mi">1</span><span class="p">)</span> <span class="o">=</span> <span class="n">U</span><span class="p">;</span>  
    <span class="n">u_new</span><span class="p">(:,</span> <span class="k">end</span><span class="p">)</span> <span class="o">=</span> <span class="n">u_new</span><span class="p">(:,</span> <span class="k">end</span><span class="o">-</span><span class="mi">1</span><span class="p">);</span> 
    <span class="n">v_new</span><span class="p">(:,</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="k">end</span><span class="p">])</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> 

    <span class="c1">% No-slip condition at cylinder</span>
    <span class="n">u_new</span><span class="p">(</span><span class="n">cylinder_mask</span><span class="p">)</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="n">v_new</span><span class="p">(</span><span class="n">cylinder_mask</span><span class="p">)</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

    <span class="c1">% Pressure correction using central difference</span>
    <span class="n">p_new</span> <span class="o">=</span> <span class="n">p</span> <span class="o">-</span> <span class="n">dt</span> <span class="o">*</span> <span class="n">rho</span> <span class="o">*</span> <span class="p">((</span><span class="n">p</span><span class="p">(:,</span> <span class="p">[</span><span class="mi">2</span><span class="p">:</span><span class="k">end</span><span class="p">,</span> <span class="k">end</span><span class="p">])</span> <span class="o">-</span> <span class="mi">2</span><span class="o">*</span><span class="n">p</span> <span class="o">+</span> <span class="n">p</span><span class="p">(:,</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">:</span><span class="k">end</span><span class="o">-</span><span class="mi">1</span><span class="p">]))</span> <span class="p">/</span> <span class="n">dx</span><span class="o">^</span><span class="mi">2</span> <span class="k">...</span>
                          <span class="o">+</span> <span class="p">(</span><span class="n">p</span><span class="p">([</span><span class="mi">2</span><span class="p">:</span><span class="k">end</span><span class="p">,</span> <span class="k">end</span><span class="p">],</span> <span class="p">:)</span> <span class="o">-</span> <span class="mi">2</span><span class="o">*</span><span class="n">p</span> <span class="o">+</span> <span class="n">p</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">:</span><span class="k">end</span><span class="o">-</span><span class="mi">1</span><span class="p">],</span> <span class="p">:))</span> <span class="p">/</span> <span class="n">dy</span><span class="o">^</span><span class="mi">2</span><span class="p">);</span>

    <span class="c1">% Update fields</span>
    <span class="n">u</span> <span class="o">=</span> <span class="n">u_new</span><span class="p">;</span>
    <span class="n">v</span> <span class="o">=</span> <span class="n">v_new</span><span class="p">;</span>
    <span class="n">p</span> <span class="o">=</span> <span class="n">p_new</span><span class="p">;</span>

    <span class="c1">% Monitor convergence</span>
    <span class="k">if</span> <span class="nb">mod</span><span class="p">(</span><span class="n">iter</span><span class="p">,</span> <span class="mi">100</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span>
        <span class="nb">fprintf</span><span class="p">(</span><span class="s1">'Iteration %d\n'</span><span class="p">,</span> <span class="n">iter</span><span class="p">);</span>
    <span class="k">end</span>
<span class="k">end</span>
</code></pre></div></div> <hr/> <h2 id="drag-coefficient-calculation">Drag Coefficient Calculation</h2> <p>We’ll now compute the drag force and determine the drag coefficient:</p> <div class="language-matlab highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">% Compute drag force components</span>
<span class="n">fx</span> <span class="o">=</span> <span class="o">-</span><span class="nb">trapz</span><span class="p">(</span><span class="n">y</span><span class="p">,</span> <span class="n">p</span><span class="p">(:,</span> <span class="nb">round</span><span class="p">(</span><span class="n">Nx</span><span class="p">/</span><span class="mi">2</span><span class="p">)));</span>  <span class="c1">% Pressure force contribution</span>
<span class="n">tau_wall</span> <span class="o">=</span> <span class="n">mu</span> <span class="o">*</span> <span class="p">(</span><span class="n">u</span><span class="p">(:,</span> <span class="nb">round</span><span class="p">(</span><span class="n">Nx</span><span class="p">/</span><span class="mi">2</span><span class="p">))</span> <span class="o">-</span> <span class="mi">0</span><span class="p">)</span> <span class="p">/</span> <span class="n">dx</span><span class="p">;</span> <span class="c1">% Shear stress at the wall</span>
<span class="n">fv</span> <span class="o">=</span> <span class="nb">trapz</span><span class="p">(</span><span class="n">y</span><span class="p">,</span> <span class="n">tau_wall</span><span class="p">);</span>  <span class="c1">% Viscous force contribution</span>

<span class="c1">% Total drag force</span>
<span class="n">Fd</span> <span class="o">=</span> <span class="n">fx</span> <span class="o">+</span> <span class="n">fv</span><span class="p">;</span>

<span class="c1">% Drag coefficient calculation</span>
<span class="n">A</span> <span class="o">=</span> <span class="n">D</span><span class="p">;</span> <span class="c1">% Projected area for 2D cylinder</span>
<span class="n">Cd</span> <span class="o">=</span> <span class="n">Fd</span> <span class="p">/</span> <span class="p">(</span><span class="mf">0.5</span> <span class="o">*</span> <span class="n">rho</span> <span class="o">*</span> <span class="n">U</span><span class="o">^</span><span class="mi">2</span> <span class="o">*</span> <span class="n">A</span><span class="p">);</span>

<span class="nb">fprintf</span><span class="p">(</span><span class="s1">'Drag Coefficient (Cd): %.4f\n'</span><span class="p">,</span> <span class="n">Cd</span><span class="p">);</span>
</code></pre></div></div> <hr/> <h2 id="post-processing-and-visualization">Post Processing and Visualization</h2> <p>Finally, we’ll visualize the results with velocity magnitude contours and streamlines.</p> <h3 id="velocity-contour-plot">Velocity Contour Plot</h3> <div class="language-matlab highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nb">figure</span><span class="p">;</span>
<span class="nb">contourf</span><span class="p">(</span><span class="n">X</span><span class="p">,</span> <span class="n">Y</span><span class="p">,</span> <span class="nb">sqrt</span><span class="p">(</span><span class="n">u</span><span class="o">.^</span><span class="mi">2</span> <span class="o">+</span> <span class="n">v</span><span class="o">.^</span><span class="mi">2</span><span class="p">),</span> <span class="mi">20</span><span class="p">);</span>
<span class="nb">colorbar</span><span class="p">;</span>
<span class="nb">title</span><span class="p">(</span><span class="s1">'Velocity Magnitude Contour'</span><span class="p">);</span>
<span class="nb">xlabel</span><span class="p">(</span><span class="s1">'X'</span><span class="p">);</span>
<span class="nb">ylabel</span><span class="p">(</span><span class="s1">'Y'</span><span class="p">);</span>
<span class="nb">axis</span> <span class="n">equal</span><span class="p">;</span>
</code></pre></div></div> <h3 id="streamline-plot">Streamline Plot</h3> <div class="language-matlab highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nb">figure</span><span class="p">;</span>
<span class="nb">quiver</span><span class="p">(</span><span class="n">X</span><span class="p">,</span> <span class="n">Y</span><span class="p">,</span> <span class="n">u</span><span class="p">,</span> <span class="n">v</span><span class="p">);</span>
<span class="nb">title</span><span class="p">(</span><span class="s1">'Velocity Field'</span><span class="p">);</span>
<span class="nb">xlabel</span><span class="p">(</span><span class="s1">'X'</span><span class="p">);</span>
<span class="nb">ylabel</span><span class="p">(</span><span class="s1">'Y'</span><span class="p">);</span>
<span class="nb">axis</span> <span class="n">equal</span><span class="p">;</span>
</code></pre></div></div> <hr/> <h2 id="results-and-comparison">Results and Comparison</h2> <p>For low Reynolds numbers, the analytical drag coefficient for a 2D cylinder is:</p> <p>[ C_d = \frac{8\pi}{\text{Re}} ]</p> <p>Let’s compare our computed drag coefficient with the analytical value:</p> <div class="language-matlab highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">Cd_analytical</span> <span class="o">=</span> <span class="mi">8</span> <span class="o">*</span> <span class="nb">pi</span> <span class="p">/</span> <span class="n">Re</span><span class="p">;</span>
<span class="nb">fprintf</span><span class="p">(</span><span class="s1">'Analytical Drag Coefficient: %.4f\n'</span><span class="p">,</span> <span class="n">Cd_analytical</span><span class="p">);</span>
<span class="nb">fprintf</span><span class="p">(</span><span class="s1">'Error: %.2f%%\n'</span><span class="p">,</span> <span class="nb">abs</span><span class="p">(</span><span class="n">Cd</span> <span class="o">-</span> <span class="n">Cd_analytical</span><span class="p">)</span> <span class="p">/</span> <span class="n">Cd_analytical</span> <span class="o">*</span> <span class="mi">100</span><span class="p">);</span>
</code></pre></div></div> <h2 id="further-improvements">Further Improvements</h2> <p>To enhance this model, consider:</p> <ul> <li>Refining the grid resolution for better accuracy.</li> <li>Implementing higher-order numerical schemes.</li> <li>Extending to 3D simulations.</li> </ul> <hr/> <p>I hope you found this tutorial helpful. Feel free to try it out and experiment with different parameters!</p>]]></content><author><name></name></author><category term="computational"/><category term="dynamics"/><summary type="html"><![CDATA[Simulating Flow Over a Cylinder Using MATLAB and the Lattice Boltzmann Methoe]]></summary></entry><entry><title type="html">Integral Table</title><link href="https://coltonkawamura.github.io/coltonkawamura/blog/2023/integral-table/" rel="alternate" type="text/html" title="Integral Table"/><published>2023-04-24T16:40:16+00:00</published><updated>2023-04-24T16:40:16+00:00</updated><id>https://coltonkawamura.github.io/coltonkawamura/blog/2023/integral-table</id><content type="html" xml:base="https://coltonkawamura.github.io/coltonkawamura/blog/2023/integral-table/"><![CDATA[\[\int A x^2 \sin^2(kx) \, dx = \frac{A}{6} x^3 - \frac{A}{4k^2} x^2 \sin(2kx) - \frac{A}{4k^3} x \cos(2kx) + \frac{A}{8k^3} \sin(2kx) + C.\] <p><strong>Definite Integrals</strong></p> \[\int_0^\pi \cos^2(x) \, dx = \frac{\pi}{2}\] <p>The area under \(\cos\) and \(\cos^2\) is \(\pi\) times the amplitude. Since our amplitude is only \(1\) and the range is only have of a full cycle, the area under is \(\pi/2\). So for a full cycle, it should be twice a half-cycle, or \(\pi\), so,</p> \[\int_0^{2\pi} \cos^2(x) \, dx=\pi.\]]]></content><author><name></name></author><category term="math"/><category term="integrals"/><summary type="html"><![CDATA[Integrals that I look up way too often.]]></summary></entry><entry><title type="html">Classical Mechanics References</title><link href="https://coltonkawamura.github.io/coltonkawamura/blog/2023/classical-mechanics-references/" rel="alternate" type="text/html" title="Classical Mechanics References"/><published>2023-03-20T18:37:00+00:00</published><updated>2023-03-20T18:37:00+00:00</updated><id>https://coltonkawamura.github.io/coltonkawamura/blog/2023/classical-mechanics-references</id><content type="html" xml:base="https://coltonkawamura.github.io/coltonkawamura/blog/2023/classical-mechanics-references/"><![CDATA[<h3 id="lagrangian">Lagrangian</h3> \[\frac{d}{dt} \left( \frac{\partial L}{\partial \dot{q}_j} \right) = \frac{\partial L}{\partial q_j}\] <p>which is just newton’s second law</p> \[m \ddot{q}_j= -\nabla U(q)\]]]></content><author><name></name></author><category term="physics"/><category term="classical"/><summary type="html"><![CDATA[My most used classical mechanics references.]]></summary></entry><entry><title type="html">Matrix Operations</title><link href="https://coltonkawamura.github.io/coltonkawamura/blog/2023/matrix-operations/" rel="alternate" type="text/html" title="Matrix Operations"/><published>2023-03-20T15:59:00+00:00</published><updated>2023-03-20T15:59:00+00:00</updated><id>https://coltonkawamura.github.io/coltonkawamura/blog/2023/matrix-operations</id><content type="html" xml:base="https://coltonkawamura.github.io/coltonkawamura/blog/2023/matrix-operations/"><![CDATA[<h2 id="cross-product-of-two-vectors">Cross Product of Two Vectors</h2> <p>Given two vectors:</p> \[\mathbf{A} = \begin{bmatrix} a \\ b \\ c \end{bmatrix}, \quad \mathbf{B} = \begin{bmatrix} d \\ e \\ f \end{bmatrix}\] <p>The cross product $\mathbf{A} \times \mathbf{B}$ is given by the determinant of a 3x3 matrix:</p> \[\mathbf{A} \times \mathbf{B} = \begin{vmatrix} \hat{i} &amp; \hat{j} &amp; \hat{k} \\ a &amp; b &amp; c \\ d &amp; e &amp; f \end{vmatrix}\] <h3 id="components">Components:</h3> <ul> <li> <p><strong>X-component</strong>: \(\hat{i} \cdot \begin{vmatrix} b &amp; c \\ e &amp; f \end{vmatrix} = bf - ce\)</p> </li> <li> <p><strong>Y-component</strong>: \(-\hat{j} \cdot \begin{vmatrix} a &amp; c \\ d &amp; f \end{vmatrix} = -(af - cd)\)</p> </li> <li> <p><strong>Z-component</strong>: \(\hat{k} \cdot \begin{vmatrix} a &amp; b \\ d &amp; e \end{vmatrix} = ae - bd\)</p> </li> </ul> <h3 id="resulting-vector">Resulting Vector:</h3> \[\mathbf{A} \times \mathbf{B} = \left( bf - ce, -(af - cd), ae - bd \right)\] <h2 id="determinant">Determinant</h2> \[A = \begin{bmatrix} a &amp; b &amp; c \\ d &amp; e &amp; f \\ g &amp; h &amp; i \end{bmatrix}\] \[\text{det}(A) = a(ei - fh) - b(di - fg) + c(dh - eg)\]]]></content><author><name></name></author><category term="math"/><category term="matrix"/><summary type="html"><![CDATA[A references for matrix operations that I use often.]]></summary></entry><entry><title type="html">Electrodynamics References</title><link href="https://coltonkawamura.github.io/coltonkawamura/blog/2022/electrodynamics-references/" rel="alternate" type="text/html" title="Electrodynamics References"/><published>2022-12-10T15:59:00+00:00</published><updated>2022-12-10T15:59:00+00:00</updated><id>https://coltonkawamura.github.io/coltonkawamura/blog/2022/electrodynamics-references</id><content type="html" xml:base="https://coltonkawamura.github.io/coltonkawamura/blog/2022/electrodynamics-references/"><![CDATA[<h2 id="maxwells-equations">Maxwell’s Equations</h2> <h3 id="in-general">In General:</h3> \[\begin{aligned} \nabla \cdot \mathbf{E} &amp;= \frac{1}{\epsilon_0} \rho \\ \\ \nabla \times \mathbf{E} &amp;= -\frac{\partial \mathbf{B}}{\partial t} \\ \\ \nabla \cdot \mathbf{B} &amp;= 0 \\ \\ \nabla \times \mathbf{B} &amp;= \mu_0 \mathbf{J} + \mu_0 \epsilon_0 \frac{\partial \mathbf{E}}{\partial t} \end{aligned}\] <h3 id="in-matter">In Matter:</h3> \[\begin{aligned} \nabla \cdot \mathbf{D} &amp;= \rho_f \\ \\ \nabla \times \mathbf{E} &amp;= -\frac{\partial \mathbf{B}}{\partial t} \\ \\ \nabla \cdot \mathbf{B} &amp;= 0 \\ \\ \nabla \times \mathbf{H} &amp;= \mathbf{J}_f + \frac{\partial \mathbf{D}}{\partial t} \end{aligned}\] <h2 id="auxillary-fields">Auxillary Fields:</h2> \[\mathbf{D} = \epsilon_0 \mathbf{E} + \mathbf{P}\] \[\mathbf{H} = \frac{1}{\mu_0} \mathbf{B} - \mathbf{M}\] <p>In Linear Media:</p> \[\mathbf{P} = \epsilon_0 \chi_e \mathbf{E}, \quad \mathbf{D} = \epsilon \mathbf{E}\] \[\mathbf{M} = \chi_m \mathbf{H}, \quad \mathbf{H} = \frac{1}{\mu} \mathbf{B}\] <h2 id="potentials">Potentials</h2> \[\mathbf{E} = -\nabla V - \frac{\partial \mathbf{A}}{\partial t}, \quad \mathbf{B} = \nabla \times \mathbf{A}\] <h2 id="lorentz-force-law">Lorentz Force Law</h2> \[\mathbf{F} = q (\mathbf{E} + \mathbf{v} \times \mathbf{B})\] <h2 id="energy-momentum-and-power">Energy, Momentum, and Power</h2> <p>Energy: \(\quad U = \frac{1}{2} \int \left( \epsilon_0 E^2 + \frac{1}{\mu_0} B^2 \right) d\tau\)</p> <p>Momentum: \(\quad \mathbf{P} = \epsilon_0 \int (\mathbf{E} \times \mathbf{B}) \, d\tau\)</p> <p>Poynting Vector (Power per Area): \(\quad \mathbf{S} = \frac{1}{\mu_0} (\mathbf{E} \times \mathbf{B})\)</p> <p>Larmor: \(\quad P = \frac{\mu_0}{6 \pi c} q^2 a^2\)</p>]]></content><author><name></name></author><category term="physics"/><category term="electrodynamics"/><summary type="html"><![CDATA[My most used Electrodynamics references.]]></summary></entry><entry><title type="html">Vector Identities</title><link href="https://coltonkawamura.github.io/coltonkawamura/blog/2022/vector-identities/" rel="alternate" type="text/html" title="Vector Identities"/><published>2022-02-01T17:39:00+00:00</published><updated>2022-02-01T17:39:00+00:00</updated><id>https://coltonkawamura.github.io/coltonkawamura/blog/2022/vector-identities</id><content type="html" xml:base="https://coltonkawamura.github.io/coltonkawamura/blog/2022/vector-identities/"><![CDATA[<h3 id="triple-products">Triple Products</h3> \[\mathbf{A} \cdot (\mathbf{B} \times \mathbf{C}) = \mathbf{B} \cdot (\mathbf{C} \times \mathbf{A}) = \mathbf{C} \cdot (\mathbf{A} \times \mathbf{B})\] \[\mathbf{A} \times (\mathbf{B} \times \mathbf{C}) = \mathbf{B}(\mathbf{A} \cdot \mathbf{C}) - \mathbf{C}(\mathbf{A} \cdot \mathbf{B})\] <h3 id="product-rules">Product Rules</h3> \[\begin{aligned} \nabla (fg) &amp;= f (\nabla g) + g (\nabla f) \\ \\ \nabla (\mathbf{A} \cdot \mathbf{B}) &amp;= \mathbf{A} \times (\nabla \times \mathbf{B}) + \mathbf{B} \times (\nabla \times \mathbf{A}) + (\mathbf{A} \cdot \nabla) \mathbf{B} + (\mathbf{B} \cdot \nabla) \mathbf{A} \\ \\ \nabla \cdot (f \mathbf{A}) &amp;= f (\nabla \cdot \mathbf{A}) + \mathbf{A} \cdot (\nabla f) \\ \\ \nabla \cdot (\mathbf{A} \times \mathbf{B}) &amp;= \mathbf{B} \cdot (\nabla \times \mathbf{A}) - \mathbf{A} \cdot (\nabla \times \mathbf{B}) \\ \\ \nabla \times (f \mathbf{A}) &amp;= f (\nabla \times \mathbf{A}) - \mathbf{A} \times (\nabla f) \\ \\ \nabla \times (\mathbf{A} \times \mathbf{B}) &amp;= (\mathbf{B} \cdot \nabla) \mathbf{A} - (\mathbf{A} \cdot \nabla) \mathbf{B} - \mathbf{B} (\nabla \cdot \mathbf{A}) + \mathbf{A} (\nabla \cdot \mathbf{B}) \end{aligned}\] <h3 id="second-derivatives">Second Derivatives</h3> \[\begin{aligned} \nabla \cdot (\nabla \times \mathbf{A}) &amp;= 0 \\ \\ \nabla \times (\nabla f) &amp;= 0 \\ \\ \nabla \times (\nabla \times \mathbf{A}) &amp;= \nabla (\nabla \cdot \mathbf{A}) - \nabla^2 \mathbf{A} \end{aligned}\] <h3 id="fundamental-theorems">Fundamental Theorems</h3> <p>Gradient Theorem: \(\quad \int_a^b (\nabla f) \cdot d\mathbf{l} = f(b) - f(a)\)</p> <p>Divergence Theorem: \(\quad \int (\nabla \cdot \mathbf{A}) \, d\tau = \oint \mathbf{A} \cdot d\mathbf{a}\)</p> <p>Curl Theorem: \(\quad \int (\nabla \times \mathbf{A}) \cdot d\mathbf{a} = \oint \mathbf{A} \cdot d\mathbf{l}\)</p>]]></content><author><name></name></author><category term="math"/><category term="derivatives"/><summary type="html"><![CDATA[My most used vector identities]]></summary></entry><entry><title type="html">Vector Derivatives</title><link href="https://coltonkawamura.github.io/coltonkawamura/blog/2021/vector-derivatives/" rel="alternate" type="text/html" title="Vector Derivatives"/><published>2021-07-04T17:39:00+00:00</published><updated>2021-07-04T17:39:00+00:00</updated><id>https://coltonkawamura.github.io/coltonkawamura/blog/2021/vector-derivatives</id><content type="html" xml:base="https://coltonkawamura.github.io/coltonkawamura/blog/2021/vector-derivatives/"><![CDATA[<h3 id="cartesian">Cartesian</h3> \[\begin{aligned} \text{Cartesian:} \quad dl &amp;= dx \, \hat{x} + dy \, \hat{y} + dz \, \hat{z}; \quad d\tau = dx \, dy \, dz \\ \\ \text{Gradient:} \quad \nabla t &amp;= \frac{\partial t}{\partial x} \, \hat{x} + \frac{\partial t}{\partial y} \, \hat{y} + \frac{\partial t}{\partial z} \, \hat{z} \\ \\ \text{Divergence:} \quad \nabla \cdot \mathbf{v} &amp;= \frac{\partial v_x}{\partial x} + \frac{\partial v_y}{\partial y} + \frac{\partial v_z}{\partial z} \\ \\ \text{Curl:} \quad \nabla \times \mathbf{v} &amp;= \left( \frac{\partial v_z}{\partial y} - \frac{\partial v_y}{\partial z} \right) \, \hat{x} + \left( \frac{\partial v_x}{\partial z} - \frac{\partial v_z}{\partial x} \right) \, \hat{y} + \left( \frac{\partial v_y}{\partial x} - \frac{\partial v_x}{\partial y} \right) \, \hat{z} \\ \\ \text{Laplacian:} \quad \nabla^2 t &amp;= \frac{\partial^2 t}{\partial x^2} + \frac{\partial^2 t}{\partial y^2} + \frac{\partial^2 t}{\partial z^2} \end{aligned}\] <h3 id="spherical">Spherical</h3> \[\begin{aligned} \text{Spherical:} \quad dl &amp;= dr \, \hat{r} + r \, d\theta \, \hat{\theta} + r \sin{\theta} \, d\phi \, \hat{\phi}; \quad d\tau = r^2 \sin{\theta} \, dr \, d\theta \, d\phi \\ \\ \text{Gradient:} \quad \nabla t &amp;= \frac{\partial t}{\partial r} \, \hat{r} + \frac{1}{r} \frac{\partial t}{\partial \theta} \, \hat{\theta} + \frac{1}{r \sin{\theta}} \frac{\partial t}{\partial \phi} \, \hat{\phi} \\ \\ \text{Divergence:} \quad \nabla \cdot \mathbf{v} &amp;= \frac{1}{r^2} \frac{\partial}{\partial r} \left( r^2 v_r \right) + \frac{1}{r \sin{\theta}} \frac{\partial}{\partial \theta} \left( \sin{\theta} v_\theta \right) + \frac{1}{r \sin{\theta}} \frac{\partial v_\phi}{\partial \phi} \\ \\ \text{Curl:} \quad \nabla \times \mathbf{v} &amp;= \frac{1}{r \sin{\theta}} \left[ \frac{\partial}{\partial \theta} \left( \sin{\theta} v_\phi \right) - \frac{\partial v_\theta}{\partial \phi} \right] \, \hat{r} \\ &amp;+ \frac{1}{r} \left[ \frac{1}{\sin{\theta}} \frac{\partial v_r}{\partial \phi} - \frac{\partial}{\partial r} \left( r v_\phi \right) \right] \, \hat{\theta} \\ &amp;+ \frac{1}{r} \left[ \frac{\partial}{\partial r} \left( r v_\theta \right) - \frac{\partial v_r}{\partial \theta} \right] \, \hat{\phi} \\ \\ \text{Laplacian:} \quad \nabla^2 t &amp;= \frac{1}{r^2} \frac{\partial}{\partial r} \left( r^2 \frac{\partial t}{\partial r} \right) + \frac{1}{r^2 \sin{\theta}} \frac{\partial}{\partial \theta} \left( \sin{\theta} \frac{\partial t}{\partial \theta} \right) + \frac{1}{r^2 \sin^2{\theta}} \frac{\partial^2 t}{\partial \phi^2} \end{aligned}\] <h3 id="cylindrical">Cylindrical</h3> \[\begin{aligned} \text{Cylindrical:} \quad dl &amp;= ds \, \hat{s} + s \, d\phi \, \hat{\phi} + dz \, \hat{z}; \quad d\tau = s \, ds \, d\phi \, dz \\ \\ \text{Gradient:} \quad \nabla t &amp;= \frac{\partial t}{\partial s} \, \hat{s} + \frac{1}{s} \frac{\partial t}{\partial \phi} \, \hat{\phi} + \frac{\partial t}{\partial z} \, \hat{z} \\ \\ \text{Divergence:} \quad \nabla \cdot \mathbf{v} &amp;= \frac{1}{s} \frac{\partial}{\partial s} \left( s v_s \right) + \frac{1}{s} \frac{\partial v_\phi}{\partial \phi} + \frac{\partial v_z}{\partial z} \\ \\ \text{Curl:} \quad \nabla \times \mathbf{v} &amp;= \left[ \frac{1}{s} \frac{\partial v_z}{\partial \phi} - \frac{\partial v_\phi}{\partial z} \right] \, \hat{s} + \left[ \frac{\partial v_s}{\partial z} - \frac{\partial v_z}{\partial s} \right] \, \hat{\phi} \\ &amp;+ \frac{1}{s} \left[ \frac{\partial}{\partial s} \left( s v_\phi \right) - \frac{\partial v_s}{\partial \phi} \right] \, \hat{z} \\ \\ \text{Laplacian:} \quad \nabla^2 t &amp;= \frac{1}{s} \frac{\partial}{\partial s} \left( s \frac{\partial t}{\partial s} \right) + \frac{1}{s^2} \frac{\partial^2 t}{\partial \phi^2} + \frac{\partial^2 t}{\partial z^2} \end{aligned}\]]]></content><author><name></name></author><category term="math"/><category term="derivatives"/><summary type="html"><![CDATA[My most used vector derivatives.]]></summary></entry><entry><title type="html">Quantum References</title><link href="https://coltonkawamura.github.io/coltonkawamura/blog/2020/quantum-references/" rel="alternate" type="text/html" title="Quantum References"/><published>2020-09-28T15:12:00+00:00</published><updated>2020-09-28T15:12:00+00:00</updated><id>https://coltonkawamura.github.io/coltonkawamura/blog/2020/quantum-references</id><content type="html" xml:base="https://coltonkawamura.github.io/coltonkawamura/blog/2020/quantum-references/"><![CDATA[<h1 id="slater-determinant">Slater Determinant</h1> \[\Psi(\mathbf{x}_1, \mathbf{x}_2, \dots, \mathbf{x}_N) = \frac{1}{\sqrt{N!}} \begin{vmatrix} \chi_1(\mathbf{x}_1) &amp; \chi_2(\mathbf{x}_1) &amp; \dots &amp; \chi_N(\mathbf{x}_1) \\ \chi_1(\mathbf{x}_2) &amp; \chi_2(\mathbf{x}_2) &amp; \dots &amp; \chi_N(\mathbf{x}_2) \\ \vdots &amp; \vdots &amp; \ddots &amp; \vdots \\ \chi_1(\mathbf{x}_N) &amp; \chi_2(\mathbf{x}_N) &amp; \dots &amp; \chi_N(\mathbf{x}_N) \end{vmatrix}\] <h1 id="eigenvector-and-eigenvalues">Eigenvector and Eigenvalues</h1> <p>Given a matrix \(\mathbf{A}\), the eigenvector equation is:</p> \[\mathbf{A} \mathbf{v} = \lambda \mathbf{v}\] <h3 id="finding-eigenvalues">Finding Eigenvalues:</h3> <p>To find the eigenvalues \(\lambda\), solve the characteristic equation:</p> \[\det(\mathbf{A} - \lambda \mathbf{I}) = 0\] <h3 id="finding-eigenvectors">Finding Eigenvectors:</h3> <p>Once the eigenvalues are determined, substitute each \(\lambda\) into the equation:</p> \[(\mathbf{A} - \lambda \mathbf{I}) \mathbf{v} = 0\] <p>Solve for the eigenvector \(\mathbf{v}\).</p>]]></content><author><name></name></author><category term="physics"/><category term="quantum"/><summary type="html"><![CDATA[My most used quantum references]]></summary></entry><entry><title type="html">How to Install LAMMPS on Mac</title><link href="https://coltonkawamura.github.io/coltonkawamura/blog/2015/how-to-install-lammps-on-mac/" rel="alternate" type="text/html" title="How to Install LAMMPS on Mac"/><published>2015-11-20T15:12:00+00:00</published><updated>2015-11-20T15:12:00+00:00</updated><id>https://coltonkawamura.github.io/coltonkawamura/blog/2015/how-to-install-lammps-on-mac</id><content type="html" xml:base="https://coltonkawamura.github.io/coltonkawamura/blog/2015/how-to-install-lammps-on-mac/"><![CDATA[<p>First, open the terminal and use brew to install the core package.</p> <div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>brew <span class="nb">install </span>lammps
</code></pre></div></div> <p>Next, make sure it’s installed properly.</p> <div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>brew <span class="nb">test </span>lammps <span class="nt">-v</span>
</code></pre></div></div> <p>Now install models needed,</p> <div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>brew <span class="nb">install </span>openkim-models
</code></pre></div></div> <p>Now <a href="https://www.lammps.org/download.html">download the tarball</a>.</p> <p>Open the .tar file and place wherever you want LAMMPS to live.</p> <p>Go ahead and get yourself the mpi capability:</p> <div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>brew <span class="nb">install </span>open-mpi fftw
</code></pre></div></div> <p>Install cmake so you can create your first LAMMPS build.</p> <div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code> brew <span class="nb">install </span>cmake
</code></pre></div></div> <p>Now go the the directory where you put the .tar file. For me, it was</p> <div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nb">cd </span>Documents/lammps-2Aug2023
</code></pre></div></div> <p>Now <a href="https://coltonkawamura.github.io/coltonkawamura/blog/2015/new-lammps-build/">make your first build</a>!</p>]]></content><author><name></name></author><category term="computing"/><category term="LAMMPS"/><summary type="html"><![CDATA[A Quick Example]]></summary></entry></feed>